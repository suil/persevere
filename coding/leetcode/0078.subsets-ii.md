# Subsets II (Medium)
[90. Subsets II (Medium)](https://leetcode.com/problems/subsets-ii/description/)

Given an integer array nums that may contain duplicates, return all possible 
subsets
 (the power set).

The solution set must not contain duplicate subsets. Return the solution in any order.

Example 1:

Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]
Example 2:

Input: nums = [0]
Output: [[],[0]]

# Key insights
* Sort array first to group duplicates together for easy skipping
* Use backtracking with level-by-level generation (k=0 to n subsets)
* Skip duplicate elements at same recursion level with i > current check
* Generate all subset sizes separately then combine results

# Code
```javascript
var subsetsWithDup = function(nums) {
    nums.sort();
    
    const results = [];
    for (let k = 0; k <= nums.length; k++) {
        const output = [];
        subsetsWithDupHelper(nums, k, 0, [], output);
        results.push(...output);
    }
    return results;
};
function subsetsWithDupHelper(nums, k, current, combinations, output) {
    if (current >= nums.length || combinations.length === k) {
        if (combinations.length === k) {
            output.push([...combinations])
        }
        return;
    }
    
    for (let i = current; i < nums.length; i++) {
        if (i > current && nums[i] === nums[i - 1]) {
            continue;
        }
        const nextCurrent = i + 1;
        const nextCombinations = [...combinations, nums[i]];
        subsetsWithDupHelper(nums, k, nextCurrent, nextCombinations, output);
    }
}
```

# Complexity
**Time:** O(n * 2^n) - generates all possible subsets (2^n) and each subset creation involves copying arrays which takes O(n) time in worst case
**Space:** O(n * 2^n) - stores all 2^n subsets with average length n/2, plus O(n) recursion depth and temporary arrays
