# Wiggle Sort II
[324. Wiggle Sort II](https://leetcode.com/problems/wiggle-sort-ii/)

Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....

# Key insights
- Unlike Wiggle Sort I, this requires strict inequality (< and >)
- Sort the array, then interleave from the middle outward
- Place smaller half at even indices (from middle going left)
- Place larger half at odd indices (from end going left)
- Going backwards prevents equal adjacent elements when duplicates exist

# Code
```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var wiggleSort = function(nums) {
    const sorted = [...nums].sort((a, b) => a - b);
    let left = Math.floor((nums.length - 1) / 2);
    let right = nums.length - 1;
    console.log({left, right})

    for (let i = 0; i < nums.length; i++) {
        if (i % 2 === 0) {
            nums[i] = sorted[left--];
        } else {
            nums[i] = sorted[right--];
        }
    }

    // const sorted = [...nums].sort((a, b) => a - b);
    // const mid = Math.floor((nums.length) / 2);
    // const left = sorted.slice(0, mid);
    // const right = sorted.slice(mid);
    // console.log({sorted, left, right, mid})

    // for (let i = 0; i < nums.length; i++) {
    //     if (i % 2 === 0) {
    //         nums[i] = left.pop();
    //     } else {
    //         nums[i] = right.pop();
    //     }
    // }

    // console.log({left, right})

    // if (left.length > 0) nums[nums.length - 1] = left.pop();
    // if (right.length > 0) nums[nums.length - 1] = right.pop();
};
```

# Complexity
**Time:** O(n log n) - dominated by sorting
**Space:** O(n) - for the sorted copy of the array
