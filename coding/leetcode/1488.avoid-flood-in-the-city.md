# Avoid Flood in The City
[1488. Avoid Flood in The City](https://leetcode.com/problems/avoid-flood-in-the-city/)

Your country has an infinite number of lakes. Initially, all the lakes are empty. When it rains over a lake (rains[i] > 0), it becomes full. If it rains over a full lake, there will be a flood. Your goal is to avoid floods.

On dry days (rains[i] == 0), you can choose one full lake to dry. Return an array ans where ans[i] is the lake you choose to dry on day i (if dry day), or -1 (if rainy day). Return an empty array if it's impossible.

# Key insights
* Track which lakes are full using a map (lake -> day it was filled)
* Collect dry day indices in a sorted set (or array with binary search)
* When a lake that's already full gets rained on, find the earliest dry day after the lake was last filled
* Use that dry day to dry the lake; if no such day exists, it's impossible

# Code
```javascript
var avoidFlood = function(rains) {
    const n = rains.length;
    const ans = new Array(n).fill(-1);
    const full = new Map();       // lake -> day it was filled
    const dryDays = [];           // sorted list of available dry day indices

    for (let i = 0; i < n; i++) {
        if (rains[i] === 0) {
            dryDays.push(i);
            ans[i] = 1; // placeholder, will be overwritten if used
        } else {
            const lake = rains[i];
            if (full.has(lake)) {
                const filledDay = full.get(lake);
                // Binary search for earliest dry day after filledDay
                let lo = 0, hi = dryDays.length - 1, idx = -1;
                while (lo <= hi) {
                    const mid = Math.floor((lo + hi) / 2);
                    if (dryDays[mid] > filledDay) {
                        idx = mid;
                        hi = mid - 1;
                    } else {
                        lo = mid + 1;
                    }
                }
                if (idx === -1) return [];
                ans[dryDays[idx]] = lake;
                dryDays.splice(idx, 1);
            }
            full.set(lake, i);
            ans[i] = -1;
        }
    }

    return ans;
};
```

# Complexity
**Time:** O(n^2) - Due to splice on the dry days array. Can be improved to O(n log n) with a sorted set.**Space:** O(n) - For the full map, dry days array, and answer array.
