# Longest Valid Parentheses
[32. Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/)

Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.

# Key insights
- Use a stack to track indices of unmatched parentheses; pop matching '(' when ')' is encountered, otherwise push ')' index
- After processing, the stack contains indices of all unmatched parentheses which act as boundaries
- Add sentinel values -1 and s.length to the stack, then find the max gap between consecutive unmatched indices

# Code
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function(s) {
    const stack = [];
    let maxLen = 0;

    for (let i = 0; i < s.length; i++) {
        if (s[i] === '(') {
            stack.push(i);
        } else if (s[i] === ')') {
            if (stack.length > 0 && s[stack[stack.length - 1]] === '(') {
                stack.pop();
                // const start = stack.length === 0 ? -1 : stack[stack.length - 1];
                // if (stack.length === 0) {
                //     maxLen = Math.max(maxLen, i + 1);
                // } else {
                //     const start = stack[stack.length - 1]
                //     maxLen = Math.max(maxLen, i - start);
                // }
            } else {
                stack.push(i);
            }
        }
    }

    stack.unshift(-1);
    stack.push(s.length)
    for (let i = 1; i < stack.length; i++) {
        if (i === 0) {
            maxLen = Math.max(maxLen, stack[i]);
        } else {
            maxLen = Math.max(maxLen, stack[i] - 1 - stack[i - 1])
        }
    }
    return maxLen
};
```

# Complexity
**Time:** O(n)
**Space:** O(n)
