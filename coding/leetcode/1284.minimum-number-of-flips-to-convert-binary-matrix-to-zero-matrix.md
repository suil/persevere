# Minimum Number of Flips to Convert Binary Matrix to Zero Matrix
[1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix](https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/)

Given a m x n binary matrix mat. In one step, you can choose one cell and flip it and all the four neighbors of it if they exist (Flip is changing 1 to 0 and 0 to 1). A pair of cells are called neighbors if they share one edge.

# Key insights
- BFS over matrix states: each state is a complete matrix configuration, and each transition is flipping one cell and its neighbors
- Uses JSON.stringify of the matrix as a state key for the visited set to detect duplicate states
- Explores all possible single-cell flips at each step, finding the minimum flips to reach the all-zero matrix

# Code
```javascript
/**
 * @param {number[][]} mat
 * @return {number}
 */
var minFlips = function(mat) {
    const rowLen = mat.length;
    const colLen = mat[0].length;
    
    let queue = [];
    queue.push({ state: structuredClone(mat), steps: 0 });

    function isZeroMatix(mat) {
        for (let row = 0; row < rowLen; row++) {
            for (let col = 0; col < colLen; col++) {
                if (mat[row][col] === 1) return false;
            }
        }
        return true;
    }

    function moveToNextStates(state) {
        const nextStates = [];
        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

        for (let row = 0; row < rowLen; row++) {
            for (let col = 0; col < colLen; col++) {
                const nextState = structuredClone(state);
                nextState[row][col] = nextState[row][col] === 0 ? 1 : 0;
                for (const [drow, dcol] of directions) {
                    const nextRow = row + drow;
                    const nextCol = col + dcol;
                    if (nextState[nextRow]?.[nextCol] === undefined) continue;
                    nextState[nextRow][nextCol] = nextState[nextRow][nextCol] === 0 ? 1 : 0;
                }
                nextStates.push(nextState);
            }
        }
        return nextStates;
    }

    const visited = new Set();
    visited.add(JSON.stringify(mat));

    while (queue.length > 0) {
        const { state, steps } = queue.shift();

        if (isZeroMatix(state)) return steps;

        // generate new state based on current matix state
        const nextStates = moveToNextStates(state);

        for (const nextState of nextStates) {
            const nextStateJson = JSON.stringify(nextState);
            if (!visited.has(nextStateJson)) {
                visited.add(nextStateJson)
                queue.push({ state: nextState, steps: steps + 1 });
            }
        }
    }
    
    return -1;
};
```

# Complexity
**Time:** O(2^(m*n) * m * n) -- BFS over all possible matrix states, each generating m*n next states
**Space:** O(2^(m*n)) -- for the visited set of all possible states
