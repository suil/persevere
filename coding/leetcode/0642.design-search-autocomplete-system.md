# Design Search Autocomplete System
[642. Design Search Autocomplete System](https://leetcode.com/problems/design-search-autocomplete-system/)

Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character '#').

# Key insights
- Trie where each node stores a map of all sentences passing through it with their frequencies, enabling fast prefix lookups
- On each character input, traverse the trie to the prefix node and sort its sentence candidates by frequency (descending) then lexicographically
- On '#' input, add the completed sentence to the trie with frequency 1 and reset the current input

# Code
```javascript
/**
 * @param {string[]} sentences
 * @param {number[]} times
 */
class TrieNode {
    constructor() {
        this.children = new Map(); // Maps character to TrieNode
        this.sentences = new Map(); // Maps sentence string to its frequency (for sentences passing through this node)
    }
}

var AutocompleteSystem = function(sentences, times) {
    this.root = new TrieNode();
    this.currentInput = "";

    // Initialize the Trie with given sentences and their frequencies
    for (let i = 0; i < sentences.length; i++) {
        this.addSentence(sentences[i], times[i]);
    }
};

AutocompleteSystem.prototype.addSentence = function(sentence, frequency) {
    let node = this.root;
    for (const char of sentence) {
        if (!node.children.has(char)) {
            node.children.set(char, new TrieNode());
        }
        node = node.children.get(char);
        // Update the frequency for this sentence at this node
        node.sentences.set(sentence, (node.sentences.get(sentence) || 0) + frequency);
    }
}

/** 
 * @param {character} c
 * @return {string[]}
 */
AutocompleteSystem.prototype.input = function(c) {
    if (c === '#') {
        // End of current input sentence, add it to the system
        this.addSentence(this.currentInput, 1); // Frequency is 1 for a new completion
        this.currentInput = ""; // Reset current input
        return [];
    } else {
        this.currentInput += c;
        let node = this.root;
        
        // Traverse the Trie based on currentInput
        for (const char of this.currentInput) {
            if (!node.children.has(char)) {
                // No sentences found for this prefix
                return [];
            }
            node = node.children.get(char);
        }

        // At this point, 'node' is the TrieNode corresponding to 'this.currentInput' prefix.
        // Collect all sentences that have this prefix and their frequencies.
        const candidates = [];
        for (const [sentence, freq] of node.sentences.entries()) {
            candidates.push([sentence, freq]);
        }

        // Sort the candidates based on frequency (descending) and then lexicographically (ascending)
        candidates.sort((a, b) => {
            if (a[1] !== b[1]) {
                return b[1] - a[1]; // Sort by frequency (descending)
            } else {
                return a[0].localeCompare(b[0]); // Sort by sentence lexicographically (ascending)
            }
        });

        // Return the top 3 sentences
        return candidates.slice(0, 3).map(item => item[0]);
    }
};

/** 
 * Your AutocompleteSystem object will be instantiated and called as such:
 * var obj = new AutocompleteSystem(sentences, times)
 * var param_1 = obj.input(c)
 */
```

# Complexity
**Time:** O(p + s log s) per input call where p = prefix length and s = number of matching sentences (for sorting)
**Space:** O(t * s) where t = total characters across all sentences and s = number of sentences (stored at each trie node)
