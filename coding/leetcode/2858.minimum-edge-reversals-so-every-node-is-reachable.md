# Minimum Edge Reversals So Every Node Is Reachable
[2858. Minimum Edge Reversals So Every Node Is Reachable](https://leetcode.com/problems/minimum-edge-reversals-so-every-node-is-reachable/)

There is a simple directed graph with n nodes labeled from 0 to n - 1. The graph would form a tree if its edges were bi-directional.

You are given an integer n and a 2D integer array edges, where edges[i] = [ui, vi] indicates that there is a directed edge from node ui to node vi.

Return an integer array answer, where answer[i] is the minimum number of edge reversals so that every node can be reached from node i.

# Key insights
* Build a bidirectional adjacency list, marking each edge as forward (cost 0) or reverse (cost 1)
* Root the tree at node 0 and DFS to compute the reversal cost for node 0
* Re-root the tree using a second DFS: when moving the root from parent to child, if the edge is forward (parentâ†’child), we need one more reversal; if reverse, one fewer
* This gives O(n) total instead of O(n^2) from computing each node independently

# Code
```javascript
var minEdgeReversals = function(n, edges) {
    const adj = Array.from({ length: n }, () => []);
    for (const [u, v] of edges) {
        adj[u].push({ node: v, cost: 0 }); // forward edge, no reversal needed
        adj[v].push({ node: u, cost: 1 }); // reverse edge, reversal needed
    }

    const result = new Array(n).fill(0);

    // DFS from node 0 to compute its reversal cost
    function dfs(node, parent) {
        for (const { node: neighbor, cost } of adj[node]) {
            if (neighbor === parent) continue;
            result[0] += cost;
            dfs(neighbor, node);
        }
    }
    dfs(0, -1);

    // Re-root DFS
    function reroot(node, parent) {
        for (const { node: neighbor, cost } of adj[node]) {
            if (neighbor === parent) continue;
            // Moving root from node to neighbor:
            // cost 0 (forward) means we now need to reverse it (+1)
            // cost 1 (reverse) means we no longer need to reverse it (-1)
            result[neighbor] = result[node] + (cost === 0 ? 1 : -1);
            reroot(neighbor, node);
        }
    }
    reroot(0, -1);

    return result;
};
```

# Complexity
**Time:** O(n) - Two DFS passes, each visiting every node and edge once.

**Space:** O(n) - Adjacency list, result array, and recursion stack use linear space.
