# Majority Element
[169. Majority Element](https://leetcode.com/problems/majority-element/)

Sorting:

Divide and Conquer:

Boyer-Moore Voting Algorithm:

# Key insights
* Sort array to group identical elements together
* Majority element guaranteed at middle index after sorting
* Leverages majority element property: appears >n/2 times
* O(n log n) time due to sorting, O(1) extra space

# Code
```javascript
var majorityElement = function(nums) {
    nums.sort();
    return nums[Math.floor(nums.length / 2)];
};
```
```javascript
var majorityElement = function(nums) {
    return majorityElementDivideAndConquer(nums, 0, nums.length - 1);
};
function majorityElementDivideAndConquer(nums, lo, hi) {
    // base case; the only element in an array of size 1 is the majority
    // element.
    if (lo === hi) { return nums[lo]; }

    // recurse on left and right halves of this slice.
    const mid = Math.floor(lo + (hi - lo) / 2);
    const left = majorityElementDivideAndConquer(nums, lo, mid);
    const right = majorityElementDivideAndConquer(nums, mid + 1, hi);

    // if the two halves agree on the majority element, return it.
    if (left === right) { return left; }

    // otherwise, count each element and return the "winner".
    const leftCount = countInRange(nums, left, lo, hi);
    const rightCount = countInRange(nums, right, lo, hi);

    return leftCount > rightCount ? left : right;
}
function countInRange(nums, num, lo, hi) {
    let count = 0;
    for (let i = lo; i <= hi; i++) {
        if (nums[i] == num) {
            count++;
        }
    }
    return count;
}
```
```javascript
var majorityElement = function(nums) {
    int cnt = 0, majority = nums[0];
    for (num of nums) {
        majority = (cnt == 0) ? num : majority;
        cnt = (majority == num) ? cnt + 1 : cnt - 1;
    }
    return majority;
}
```

# Complexity
**Solution 1:**
**Time:** O(n log n) - sorting the array takes O(n log n) time
**Space:** O(1) - only uses constant extra space (assuming in-place sort)

**Solution 2:**
**Time:** O(n log n) - divide and conquer creates log n levels, each level does O(n) work for counting
**Space:** O(log n) - recursion stack depth is log n for the divide and conquer approach

**Solution 3:**
**Time:** O(n) - single pass through the array with constant work per element
**Space:** O(1) - only uses two variables regardless of input size
