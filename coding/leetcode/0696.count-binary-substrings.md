# Count Binary Substrings
[696. Count Binary Substrings](https://leetcode.com/problems/count-binary-substrings/)

Given a binary string s, return the number of non-empty substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.

Substrings that occur multiple times are counted the number of times they occur.

Example 1:

Input: s = "00110011"
Output: 6
Explanation: There are 6 substrings: "0011", "01", "1100", "10", "0011", "01"
Example 2:

Input: s = "10101"
Output: 4
Explanation: There are 4 substrings: "10", "01", "10", "01"

Constraints:

1 <= s.length <= 10^5
s[i] is either '0' or '1'.

# Key insights

- Group the string into **runs of consecutive identical characters**: `"00110011"` → runs `[2, 2, 2, 2]`
- For each adjacent pair of runs, `min(run1, run2)` counts the valid substrings between them (you can form substrings of length 2, 4, ... up to `2 * min`)
- No need to build the full runs array — track only `prev` (last run length) and `cur` (current run length)
- When the character changes: `count += min(prev, cur)`, then `prev = cur`, reset `cur = 1`
- Don't forget to add `min(prev, cur)` once more after the loop for the final run pair

# Code
```javascript
var countBinarySubstrings = function(s) {
    let prev = 0;
    let cur = 1;
    let count = 0;

    for (let i = 1; i < s.length; i++) {
        if (s[i] === s[i - 1]) {
            cur++;
        } else {
            count += Math.min(prev, cur);
            prev = cur;
            cur = 1;
        }
    }
    count += Math.min(prev, cur);
    return count;
};
```
# Complexity

- **Time**: O(n) — single pass through the string
- **Space**: O(1) — only `prev`, `cur`, and `count` are tracked
