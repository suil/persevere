# Bus Routes
[815. Bus Routes](https://leetcode.com/problems/bus-routes/)

You are given an array routes where routes[i] is a bus route that the ith bus repeats forever. For example, if routes[0] = [1, 5, 7], this means that the 0th bus travels in the sequence 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> ... forever.

You will start at the bus stop source (not on any bus), and you want to go to the bus stop target. You can travel between bus stops by buses only.

Return the least number of buses you must take to travel from source to target. Return -1 if it is not possible.

Example 1:

Input: routes = [[1,2,7],[3,6,7]], source = 1, target = 6
Output: 2
Explanation: Take the first bus to stop 7, then the second bus to stop 6.
Example 2:

Input: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
Output: -1

Constraints:

1 <= routes.length <= 500
1 <= routes[i].length <= 10^5
All the values of routes[i] are unique.
sum(routes[i].length) <= 10^5
0 <= routes[i][j] < 10^6
0 <= source, target < 10^6

# Key insights

- **BFS on bus routes, not stops** — the "distance" is the number of buses taken, so treat each bus route as a node, not each stop
- Build a **stop-to-routes map**: for each stop, record which routes serve it — this lets you find which routes are reachable from any stop
- BFS level = number of buses taken. Start by enqueuing all routes that serve `source`, each at distance 1
- When processing a route, check all its stops: if `target` is found, return current distance; otherwise enqueue all unvisited routes that share a stop
- Mark routes as visited (not stops) to avoid revisiting the same bus

# Code
```javascript
var numBusesToDestination = function(routes, source, target) {
    if (source === target) return 0;

    const stopToBusMap = new Map();
    for (let bus = 0; bus < routes.length; bus++) {
        const route = routes[bus];
        for (const stop of route) {
            if (!stopToBusMap.has(stop)) {
                stopToBusMap.set(stop, []);
            }
            stopToBusMap.get(stop).push(bus);
        }
    }

    if (!stopToBusMap.has(source) || !stopToBusMap.has(target)) return -1;

    const queue = [{ stop: source, numOfBus: 0 }];
    const visitedBuses = new Set();
    const visitedStops = new Set([source]);

    while (queue.length > 0) {
        const curr = queue.shift();

        if (curr.stop === target) return curr.numOfBus;

        const buses = stopToBusMap.get(curr.stop)
        for (const bus of buses) {
            if (visitedBuses.has(bus)) continue;
            visitedBuses.add(bus);

            const stops = routes[bus];
            const nextNumOfBus = curr.numOfBus + 1;
            for (const nextStop of stops) {
                if (visitedStops.has(nextStop)) continue;
                visitedStops.add(nextStop);
                queue.push({ stop: nextStop, numOfBus: nextNumOfBus });
            }
        }
    }

    return -1;
};
```

# Complexity

- **Time**: O(N) where N = sum of all route lengths — each stop and route is processed at most once
- **Space**: O(N + R) — the stop-to-routes map stores N entries, plus O(R) for the visited set and queue where R = number of routes
