# Palindrome Partitioning II
[132. Palindrome Partitioning II](https://leetcode.com/problems/palindrome-partitioning-ii/)

Given a string s, partition s such that every substring of the partition is a palindrome.

# Key insights
- Precompute a 2D palindrome table dp[start][end] using DP so palindrome checks are O(1)
- Use memoized recursion (backtrack) to find the minimum number of cuts: try every palindromic prefix from the current index and recurse on the remainder
- The palindrome table avoids repeated O(n) palindrome checks in the recursive step

# Code
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var minCut = function(s) {
    function isPalindrome(s) {
        let start = 0, end = s.length - 1;
        while (start < end) {
            if (s[start++] !== s[end--]) {
                return false;
            }
        }
        return true;
    };

    const dp = Array(s.length).fill().map(() => Array(s.length).fill(false));
    for (let end = 0; end < s.length; end++) {
        for (let start = 0; start <= end; start++) {
            if (s[start] === s[end]) {
                if (end - start + 1 <= 2) {
                    dp[start][end] = true;
                } else {
                    dp[start][end] = dp[start + 1][end - 1];
                }
            }
        }
    }

    function backtrack(index, memo = {}) {
        if (index === s.length) return -1;
        if (index in memo) return memo[index];
        
        let min = Infinity;
        for (let i = index; i < s.length; i++) {
            // const currStr = s.substring(index, i + 1);
            // if (isPalindrome(currStr)) {
            //     min = Math.min(min, 1 + backtrack(i + 1));
            // }
            if (dp[index][i] === true) {
                min = Math.min(min, 1 + backtrack(i + 1, memo));
            }
        }
        memo[index] = min;
        return min;
    }

    return backtrack(0);
};
```

# Complexity
**Time:** O(n^2)
**Space:** O(n^2) for the palindrome table
