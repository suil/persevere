# My Calendar III
[732. My Calendar III](https://leetcode.com/problems/my-calendar-iii/)

A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is common to all k events.)

# Key insights
- Use a sweep line approach: store +1 at start time and -1 at end time
- After adding the new event, sort all time points and sweep through to find the maximum concurrent events
- The maximum active count during the sweep is the k-booking number

# Code
```javascript

var MyCalendarThree = function() {
    this.times = [];
};

/** 
 * @param {number} startTime 
 * @param {number} endTime
 * @return {number}
 */
MyCalendarThree.prototype.book = function(startTime, endTime) {
    this.times.push([startTime, 1]);
    this.times.push([endTime, -1]);

    this.times.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
    let max = -Infinity;
    let active = 0;

    for (const [time, count] of this.times) {
        active += count;
        max = Math.max(max, active);
    }

    return max;
};

/** 
 * Your MyCalendarThree object will be instantiated and called as such:
 * var obj = new MyCalendarThree()
 * var param_1 = obj.book(startTime,endTime)
 */
```

# Complexity
**Time:** O(n log n) per book call where n is the number of events so far (due to sorting)
**Space:** O(n) for storing all time points
