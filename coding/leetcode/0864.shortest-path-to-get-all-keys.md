# Shortest Path to Get All Keys
[864. Shortest Path to Get All Keys](https://leetcode.com/problems/shortest-path-to-get-all-keys/)

You are given an m x n grid grid where:

# Key insights
- BFS with state = (row, col, keys bitmask) to find shortest path
- Use bitmask to track collected keys (bit i = 1 means key 'a'+i is collected)
- Can only pass through a lock if we have the corresponding key
- Track visited states to avoid revisiting same (position, keys) combination

# Code
```javascript
/**
 * @param {string[]} grid
 * @return {number}
 */
var shortestPathAllKeys = function(grid) {
    const rowLen = grid.length;
    const colLen = grid[0].length;

    let startRow, startCol;
    let totalKeys = 0;
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            const cell = grid[row][col];
            if (cell === '@') {
                startRow = row;
                startCol = col;
            }
            if (cell >= 'a' && cell <= 'f') {
                totalKeys |= 1 << (cell.charCodeAt(0) - 'a'.charCodeAt(0));
            }
        }
    }

    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
    const visited = new Set();
    let queue = [[startRow, startCol, 0]]; // [row, col, keys]
    visited.add([startRow, startCol, 0].join('-'));
    let steps = 0;

    while (queue.length > 0) {
        const nextQueue = [];
        steps++;

        for (const [row, col, keys] of queue) {
            for (const [dRow, dCol] of directions) {
                let nextRow = row + dRow;
                let nextCol = col + dCol;
                let newKeys = keys;

                if (grid[nextRow]?.[nextCol] === undefined || grid[nextRow][nextCol] === '#') continue;
                const cell = grid[nextRow][nextCol];

                if (cell >= 'a' && cell <= 'f') {
                    newKeys |= 1 << (cell.charCodeAt(0) - 'a'.charCodeAt(0));
                    if (newKeys === totalKeys) return steps;
                }

                if (cell >= 'A' && cell <= 'F') {
                    const keyBit = 1 << (cell.charCodeAt(0) - 'A'.charCodeAt(0));
                    if ((newKeys & keyBit) === 0) continue;
                }

                const state = [nextRow, nextCol, newKeys].join('-');
                if (!visited.has(state)) {
                    visited.add(state);
                    nextQueue.push([nextRow, nextCol, newKeys]);
                }
            }
        }

        queue = nextQueue;
    }

    return -1;
};
```

# Complexity
**Time:** O(m * n * 2^k) - where k is number of keys (up to 6), visiting each state once
**Space:** O(m * n * 2^k) - for visited set and queue
