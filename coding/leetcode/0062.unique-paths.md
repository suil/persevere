# Unique Paths
[62. Unique Paths](https://leetcode.com/problems/unique-paths/)

memoization:

dp:

could use formula to solve this. This is a combination problem.
the total movments is S = m + n - 2. downward movment is D = m - 1.
So the problem is C(S, D).

# Key insights
* Memoization optimizes recursive solution by caching subproblems in hash map
* Dynamic programming pattern: paths to (m,n) = paths to (m-1,n) + paths to (m,n-1)
* Base case: single row or column always has exactly 1 unique path
* String concatenation creates unique keys for 2D coordinate memoization

# Code
```javascript
function memoize(m, n, memo) {
    const key = `${m}-${n}`;
    if (memo.has(key)) {
        return memo.get(key);
    }
    if (m === 1 || n === 1) {
        return 1;
    }
    const numOfPaths = memoize(m - 1, n, memo) + memoize(m, n - 1, memo);
    memo.set(key, numOfPaths);
    return numOfPaths;
}
```
```javascript
var uniquePaths = function(m, n) {
    const dp = [...Array(m)].map(_ => [...Array(n)].fill(1));
    
    for (let row = 1; row < m; row++) {
        for (let col = 1; col < n; col++) {
            dp[row][col] = dp[row - 1][col] + dp[row][col - 1];
        }
    }
    
    return dp[m - 1][n - 1];
};
```
```java
public int uniquePaths(int m, int n) {
    int S = m + n - 2;  // total movments
    int D = m - 1;      // downward movments
    long ret = 1;
    for (int i = 1; i <= D; i++) {
        ret = ret * (S - D + i) / i;
    }
    return (int) ret;
}
```

# Complexity
**Solution 1:**
**Time:** O(m*n) - each unique subproblem (m,n) is computed once and memoized
**Space:** O(m*n) - memoization map stores results for all subproblems plus recursion stack depth

**Solution 2:**
**Time:** O(m*n) - nested loops iterate through all grid positions once
**Space:** O(m*n) - 2D DP array stores values for entire grid

**Solution 3:**
**Time:** O(min(m,n)) - single loop runs for the smaller dimension to calculate combinations
**Space:** O(1) - only constant extra variables used
