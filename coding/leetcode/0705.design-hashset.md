# Design HashSet
[705. Design HashSet](https://leetcode.com/problems/design-hashset/)

Design a HashSet without using any built-in hash table libraries.

# Key insights
- Hash table with separate chaining: use an array of buckets where each bucket is a list, with `key % prime` as the hash function
- A large prime (9377) reduces collisions by spreading keys more uniformly across buckets
- Remove uses filter to create a new bucket array without the key; contains uses includes to check membership

# Code
```javascript
/**
 * Initialize your data structure here.
 */
var MyHashSet = function() {
    this.prime = 9377; // increase the prime # to reduce collisions
    this.value = [...Array(this.prime)].map(_ => []);
};

/** 
 * @param {number} key
 * @return {void}
 */
MyHashSet.prototype.add = function(key) {
    const idx = key % this.prime;
    this.value[idx].push(key);
};

/** 
 * @param {number} key
 * @return {void}
 */
MyHashSet.prototype.remove = function(key) {
    const idx = key % this.prime;
    this.value[idx] = this.value[idx].filter(x => x !== key);
};

/**
 * Returns true if this set contains the specified element 
 * @param {number} key
 * @return {boolean}
 */
MyHashSet.prototype.contains = function(key) {
    const idx = key % this.prime;
    return this.value[idx].includes(key);
};

/** 
 * Your MyHashSet object will be instantiated and called as such:
 * var obj = new MyHashSet()
 * obj.add(key)
 * obj.remove(key)
 * var param_3 = obj.contains(key)
 */
```

# Complexity
**Time:** O(n/p) average per operation where n is the number of elements and p is the prime (bucket size)
**Space:** O(p + n) -- p buckets plus n stored elements
