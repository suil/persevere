# Pacific Atlantic Water Flow
[417. Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/)

There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.

# Key insights
- Reverse thinking: instead of flowing downhill to oceans, flow uphill from ocean edges
- DFS from Pacific edges (left column, top row) marking reachable cells
- DFS from Atlantic edges (right column, bottom row) marking reachable cells
- Answer is cells reachable from both oceans (intersection of both visited sets)

# Code
```javascript
/**
 * @param {number[][]} heights
 * @return {number[][]}
 */
var pacificAtlantic = function(heights) {
    const rowLen = heights.length;
    const colLen = heights[0].length;

    const pacificVisited = Array(rowLen).fill().map(() => Array(colLen).fill(false));
    const atlanticVisited = Array(rowLen).fill().map(() => Array(colLen).fill(false));

    const directions = [[0, 1], [0, -1], [-1, 0], [1, 0]];

    function dfs(startRow, startCol, visited) {
        if (heights[startRow]?.[startCol] === undefined || visited[startRow][startCol] === true) {
            return;
        }

        visited[startRow][startCol] = true;

        for (const [deltaRow, deltaCol] of directions) {
            const nextRow = startRow + deltaRow;
            const nextCol = startCol + deltaCol;

            if (heights[nextRow]?.[nextCol] !== undefined && heights[nextRow][nextCol] >= heights[startRow][startCol]) {
                dfs(nextRow, nextCol, visited);
            } 
        }
    }
    
    for (let row = 0; row < rowLen; row++) {
        dfs(row, 0, pacificVisited);
        dfs(row, colLen - 1, atlanticVisited);
    }

    for (let col = 0; col < colLen; col++) {
        dfs(0, col, pacificVisited);
        dfs(rowLen - 1, col, atlanticVisited);
    }

    const res = [];
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (pacificVisited[row][col] && atlanticVisited[row][col]) {
                res.push([row, col]);
            }
        }
    }
    return res;
};
```

# Complexity
**Time:** O(m * n) - each cell visited at most twice (once per ocean)
**Space:** O(m * n) - for the two visited arrays
