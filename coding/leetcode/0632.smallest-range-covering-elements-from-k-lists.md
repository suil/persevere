# Smallest Range Covering Elements from K Lists
[632. Smallest Range Covering Elements from K Lists](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/)

You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the k lists.

# Key insights
- Flatten all lists into (value, listIndex) pairs and sort by value to enable a sliding window approach
- Use a sliding window that expands right until all k lists are covered, then shrinks from the left to minimize the range
- Track coverage count per list; update the best range whenever all k lists are covered

# Code
```javascript
/**
 * @param {number[][]} nums
 * @return {number[]}
 */
var smallestRange = function(nums) {
    const allNumbers = [];
    const count = new Map();

    // Flatten the input and track the list index for each number
    for (let i = 0; i < nums.length; i++) {
        for (const num of nums[i]) {
            allNumbers.push([num, i]);
        }
    }

    // Sort the flattened list by value
    allNumbers.sort((a, b) => a[0] - b[0]);

    let left = 0;
    let covered = 0;
    let range = [-Infinity, Infinity];

    // Sliding window to find the smallest range
    for (let right = 0; right < allNumbers.length; right++) {
        const [value, listIndex] = allNumbers[right];
        count.set(listIndex, (count.get(listIndex) || 0) + 1);

        if (count.get(listIndex) === 1) {
            covered++;
        }

        // Shrink the window while all lists are covered
        while (covered === nums.length) {
            const [startValue] = allNumbers[left];
            if (value - startValue < range[1] - range[0]) {
                range = [startValue, value];
            }

            const [, startListIndex] = allNumbers[left];
            count.set(startListIndex, count.get(startListIndex) - 1);
            if (count.get(startListIndex) === 0) {
                covered--;
            }
            left++;
        }
    }

    return range;
};

```

# Complexity
**Time:** O(N log N) where N is the total number of elements across all lists -- dominated by sorting
**Space:** O(N) -- for the flattened and sorted array
