# Decode Ways
[91. Decode Ways](https://leetcode.com/problems/decode-ways/)

backtracking:

recursion with memoization:

DP:

# Key insights
* Uses backtracking to explore all valid decoding combinations recursively
* Hash map enables O(1) validation of numeric strings to letter mappings
* Partitions string into valid prefixes (1-2 digits) and recurses on remainder
* Base case: empty string indicates one valid complete decoding path found

# Code
```javascript
const encoding = {
    '1': 'A',
    '2': 'B',
    '3': 'C',
    '4': 'D',
    '5': 'E',
    '6': 'F',
    '7': 'G',
    '8': 'H',
    '9': 'I',
    '10': 'J',
    '11': 'K',
    '12': 'L',
    '13': 'M',
    '14': 'N',
    '15': 'O',
    '16': 'P',
    '17': 'Q',
    '18': 'R',
    '19': 'S',
    '20': 'T',
    '21': 'U',
    '22': 'V',
    '23': 'W',
    '24': 'X',
    '25': 'Y',
    '26': 'Z'
}

function numDecodingsBacktracking(s, output) {
    if (s.length === 0) {
        output.count++;
        return;
    }
    
    for (let i = 1; i <= s.length; i++) { 
        const leftStr = s.substring(0, i);
        const decoded = encoding[leftStr];
        if (!decoded) {
            break;
        }
        const nextS = s.substring(i);
        numDecodingsBacktracking(nextS, output);
    }
}
```
```javascript
var numDecodings = function(s) {
    const output = recursiveWithMemo(s, 0, new Map());
    return output;
};

function recursiveWithMemo(str, index, memo) {
    // Have we already seen this substring?
    if (memo.has(index)) {
        return memo.get(index);
    }
    
    // If the string starts with a zero, it can't be decoded
    if (str[index] === '0') {
        return 0;
    }

    // If you reach the end of the string
    // Return 1 for success.
    if (index >= str.length - 1) {
        return 1;
    }

    let ans = recursiveWithMemo(str, index + 1, memo);
    if (Number(str.substring(index, index + 2)) <= 26) {
        ans += recursiveWithMemo(str, index + 2, memo);
    }

    // Save for memoization
    memo.set(index, ans);

    return ans;
}
```
```javascript
var numDecodings = function(s) {
    if (s == null || s.length == 0) {
        return 0;
    }

    const n = s.length;
    const dp = [...Array(n)].fill(0);
    dp[0] = encodingMap.has(s[0]) ? 1 : 0;
    dp[1] = (encodingMap.has(s[1]) ? dp[0] : 0) + (encodingMap.has(s.substr(0, 2)) ? 1 : 0);

    for (let i = 2; i < s.length; i++) {
        const oneCharStr = s.substr(i, 1);
        const twoCharStr = s.substr(i - 1, 2);

        if (encodingMap.has(oneCharStr)) {
            dp[i] = dp[i - 1];
        }
        if (encodingMap.has(twoCharStr)) {
            dp[i] += dp[i - 2];
        }
    }
    return dp[s.length - 1];
};

```

# Complexity
**Solution 1:**
**Time:** O(2^n) - explores all possible ways to partition the string without memoization, leading to exponential branching
**Space:** O(n) - recursion stack depth can go up to n levels deep

**Solution 2:**
**Time:** O(n) - each subproblem from index 0 to n-1 is solved exactly once due to memoization
**Space:** O(n) - memoization map stores results for n different indices plus recursion stack space

**Solution 3:**
**Time:** O(n) - single pass through the string with constant work per position
**Space:** O(n) - dp array stores one value for each position in the string
