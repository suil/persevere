# Meeting Rooms III
[2402. Meeting Rooms III](https://leetcode.com/problems/meeting-rooms-iii/)

You are given an integer n. There are n rooms numbered from 0 to n - 1.

You are given a 2D integer array meetings where meetings[i] = [starti, endi] means that a meeting will be held during the half-open time interval [starti, endi). All the values of starti are unique.

Meetings are assigned to rooms in the following manner:
1. Each meeting will take place in the unused room with the lowest number.
2. If there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the same duration as the original meeting.
3. When a room becomes free, meetings that have an earlier original start time should be given the room.

Return the number of the room that held the most meetings. If there are multiple rooms, return the room with the lowest number.

# Key insights
* Sort meetings by start time to process them in order
* Use two min-heaps: one for available rooms (by room number) and one for busy rooms (by end time, then room number)
* When processing a meeting, free up all rooms whose meetings have ended
* If no room is available, pop the earliest-ending busy room and delay the meeting accordingly
* Track meeting count per room and return the room with the highest count

# Code
```javascript
var mostBooked = function(n, meetings) {
    meetings.sort((a, b) => a[0] - b[0]);
    
    const free = new PriorityQueue((a, b) => a - b);
    for (let i = 0; i < n; i++) {
        free.enqueue(i);
    }

    // {endTime, roomIndex}
    const busy = new PriorityQueue((a, b) => {
        return a.endTime - b.endTime || a.roomIndex - b.roomIndex;
    });

    const count = Array(n).fill(0);

    for (const [start, end] of meetings) {
        while (!busy.isEmpty() && busy.front().endTime <= start) {
            const { roomIndex } = busy.pop();
            free.push(roomIndex);
        }

        if (!free.isEmpty()) {
            const freeRoomIndex = free.pop();
            busy.push({ endTime: end, roomIndex: freeRoomIndex });
            count[freeRoomIndex]++;
        } else {
            const { endTime: earliestEndTime, roomIndex } = busy.pop();
            count[roomIndex]++;
            busy.push({ endTime: earliestEndTime + (end - start), roomIndex });
        }
    }

    let max = Math.max(...count);
    return count.findIndex(c => c === max);
};
```

# Complexity
**Time:** O(m log n + m log m) - Sorting meetings takes O(m log m). Each meeting involves at most O(log n) heap operations.**Space:** O(n + m) - Two heaps hold at most n rooms total, plus the count array.
