# Subsets II
[90. Subsets II](https://leetcode.com/problems/subsets-ii/)

Given an integer array nums that may contain duplicates, return all possible subsets (the power set).

# Key insights
- Sort the array first so duplicates are adjacent
- Backtracking: at each index, skip elements that are the same as the previous sibling at the same recursion level to avoid duplicate subsets
- Push a copy of the current path to output at every recursion level (including empty)

# Code
```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsetsWithDup = function(nums) {
    
    function backtrack(index, path, output) {
        output.push([...path]);
        if (index >= nums.length) {
            return;
        }

        for (let i = index; i < nums.length; i++) {
            if (i - 1 >= index && nums[i - 1] === nums[i]) continue;
            backtrack(i + 1, [...path, nums[i]], output);
        }
    };

    nums.sort();
    const output = [];
    backtrack(0, [], output);
    return output;
};
```

# Complexity
**Time:** O(n * 2^n)**Space:** O(n) recursion depth plus O(n * 2^n) for the output
