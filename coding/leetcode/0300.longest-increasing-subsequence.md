# Longest Increasing Subsequence
[300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence)

Memoization:

DP:

# Key insights
* Uses recursive approach with memoization to avoid recomputing subproblems
* At each position, decides whether to include or exclude current element in subsequence
* Memoization key combines current index and previous element value for state tracking
* Explores both branches (take/skip) and returns maximum length found

# Code
```javascript
var lengthOfLIS = function(nums) {
    const output = lengthOfLISBruteForce(nums, 0, -Infinity, new Map());
    return output;
};

function lengthOfLISBruteForce(nums, current, prevNum) {
    const key = `${current}-${prevNum}`;
    if (memo.has(key)) {
        return memo.get(key);
    }

    if (current >= nums.length) {
        return 0;
    }

    let taken = 0;
    if (nums[current] > prevNum) {
        taken = 1 + lengthOfLISBruteForce(nums, current + 1, nums[current]);
    }
    const notTaken = lengthOfLISBruteForce(nums, current + 1, prevNum);

    const max = Math.max(taken, notTaken);
    memo.set(key, max)
    return max;
}
```
```javascript
var lengthOfLIS = function(nums) {
    if (nums.length == 1) {
        return 1;
    }
    
    const dp = [...Array(nums.length)].fill(1);
    let maxLen = 1;
    
    for (let i = 1; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1)
                maxLen = Math.max(maxLen, dp[i]);
            }
        }
    }

    return maxLen;
};
```