# Compare Strings by Frequency of the Smallest Character
[1170. Compare Strings by Frequency of the Smallest Character](https://leetcode.com/problems/compare-strings-by-frequency-of-the-smallest-character/)

Let the function f(s) be the frequency of the lexicographically smallest character in a non-empty string s. For example, if s = "dcce" then f(s) = 2 because the lexicographically smallest character is 'c', which has a frequency of 2.

# Key insights
- Computes f(s) for each word by finding the frequency of the lexicographically smallest character in one pass
- Sorts the word f-values and uses binary search to count how many words have f(word) > f(query) for each query
- Binary search finds the first index where f(word) > f(query), then the count is the remaining elements

# Code
```javascript
/**
 * @param {string[]} queries
 * @param {string[]} words
 * @return {number[]}
 */
var numSmallerByFrequency = function(queries, words) {
    function f(word) {
        let minChar = 'z';
        let count = 0;
        for (const char of word) {
            if (char < minChar) {
                minChar = char;
                count = 1;
            } else if (char === minChar) {
                count++;
            }
        }
        return count;
    }

    const wordCounts = words.map(w => f(w)).sort((a, b) => a - b);

    const res = [];
    for (const query of queries) {
        const queryCount = f(query);

        let left = 0, right = wordCounts.length - 1;
        while (left <= right) {
            const mid = Math.floor((left + right) / 2);
            if (queryCount >= wordCounts[mid]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        res.push(wordCounts.length - left);
    }
    return res;
};
```

# Complexity
**Time:** O((W + Q) * L + W log W + Q log W) -- computing f values, sorting words, and binary search per query
**Space:** O(W) -- for the sorted word counts array
