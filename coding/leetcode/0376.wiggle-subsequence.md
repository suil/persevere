# Wiggle Subsequence
[376. Wiggle Subsequence](https://leetcode.com/problems/wiggle-subsequence)

Recursion:

DP:

# Key insights
* Uses DFS recursive approach to explore all possible wiggle subsequences
* Tracks previous two elements to determine wiggle pattern direction changes
* Base case handles arrays with length <= 1 returning 1
* Greedy initialization sets maxLength based on first two distinct elements

# Code
```javascript
var wiggleMaxLength = function(nums) {
    if (nums.length <= 1) {
        return 1;
    }

    let maxLength = nums[0] !== nums[1] ? 2 : 1;
    console.log({maxLength})
    maxLength += dfs(nums, 2, nums[1], nums[0]);
    return maxLength;
};

```
```javascript
var wiggleMaxLength = function(nums) {
    if (!nums|| nums.length == 0) {
        return 0;
    }
    let up = 1, down = 1;
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] > nums[i - 1]) {
            up = down + 1;
        } else if (nums[i] < nums[i - 1]) {
            down = up + 1;
        }
    }
    return Math.max(up, down);
};
```

# Complexity
**Solution 1:**
**Time:** O(2^n) - the DFS function explores all possible subsequences leading to exponential time complexity
**Space:** O(n) - recursion stack depth can go up to n levels in the worst case

**Solution 2:**
**Time:** O(n) - single pass through the array with constant work per element
**Space:** O(1) - only uses two variables regardless of input size
