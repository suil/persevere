# Unique Paths III
[980. Unique Paths III](https://leetcode.com/problems/unique-paths-iii/)

You are given an m x n integer array grid where grid[i][j] could be:

# Key insights
- DFS backtracking that explores all four directions from each cell, counting paths that visit every empty cell exactly once before reaching the end cell
- Pre-counts empty cells so the DFS can verify all cells are visited when the end cell (value 2) is reached
- Uses a visited Set with string keys for backtracking state, adding and removing entries as paths are explored

# Code
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var uniquePathsIII = function(grid) {
    const rowLen = grid.length;
    const colLen = grid[0].length;
    let startRow, startCol, emptyCount = 0;

    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (grid[row][col] === 1) {
                startRow = row;
                startCol = col;
            } else if (grid[row][col] === 0) {
                emptyCount++;
            }
        }
    }

    const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];
    let count = 0;
    const visited = new Set();

    function dfs(row, col, remainingEmptyCount) {
        // out of bound
        if (grid[row]?.[col] === undefined) return;

        // if (grid[row][col] === -1 || grid[row][col] === -2) return;
        if (grid[row][col] === -1 || visited.has([row, col].join('-'))) return;

        if (grid[row][col] === 2) {
            if (remainingEmptyCount === 0) {
                count++;
            }
            return;
        }

        visited.add([row, col].join('-'));
        // const oldVal = grid[row][col];
        // grid[row][col] = -2; // mark visit

        for (const [dRow, dCol] of directions) {
            const nextRow = row + dRow;
            const nextCol = col + dCol;
            dfs(nextRow, nextCol, remainingEmptyCount - 1);
        }

        // grid[row][col] = oldVal;
        visited.delete([row, col].join('-'));

    }

    dfs(startRow, startCol, emptyCount + 1);
    return count;
};
```

# Complexity
**Time:** O(4^(m*n)) -- worst case explores all possible paths through the grid
**Space:** O(m * n) -- recursion depth and visited set
