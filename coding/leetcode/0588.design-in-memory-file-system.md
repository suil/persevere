# Design In-Memory File System
[588. Design In-Memory File System](https://leetcode.com/problems/design-in-memory-file-system/)

Design a data structure that simulates an in-memory file system. Implement the FileSystem class with ls, mkdir, addContentToFile, and readContentFromFile operations.

# Key insights
* Use a trie-like structure where each node represents a directory or file
* Each node has a map of children (subdirectories/files), a content string (if it's a file), and an isFile flag
* Navigate the path by splitting on '/' and traversing the trie
* ls returns sorted contents; for a file path it returns just the filename

# Code
```javascript
var FileSystem = function() {
    this.root = { children: new Map(), content: '', isFile: false };
};

FileSystem.prototype._navigate = function(path) {
    let node = this.root;
    if (path === '/') return node;
    const parts = path.split('/').slice(1);
    for (const part of parts) {
        if (!node.children.has(part)) {
            node.children.set(part, { children: new Map(), content: '', isFile: false });
        }
        node = node.children.get(part);
    }
    return node;
};

FileSystem.prototype.ls = function(path) {
    const node = this._navigate(path);
    if (node.isFile) {
        return [path.split('/').pop()];
    }
    return [...node.children.keys()].sort();
};

FileSystem.prototype.mkdir = function(path) {
    this._navigate(path);
};

FileSystem.prototype.addContentToFile = function(filePath, content) {
    const node = this._navigate(filePath);
    node.isFile = true;
    node.content += content;
};

FileSystem.prototype.readContentFromFile = function(filePath) {
    return this._navigate(filePath).content;
};
```

# Complexity
**Time:** O(m + n log n) for ls where m is path length and n is number of entries; O(m) for other operations.

**Space:** O(total content + total paths) - Storing all file contents and directory structure.
