# Permutation in String
[567. Permutation in String](https://leetcode.com/problems/permutation-in-string/)

Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.

# Key insights
- Sliding window of size |s1| over s2, maintaining character frequency maps for both the window and s1
- At each step, add the new right character and remove the leftmost character that exits the window
- Compare frequency maps to check if the current window is a permutation of s1

# Code
```javascript
/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var checkInclusion = function(s1, s2) {
    if (s1.length > s2.length) return false;

    const freqMapS1 = new Map();
    const freqMapS2 = new Map();
    const k = s1.length;

    function isMatched(mapS1, mapS2) {
        for (const [key, count] of mapS1) {
            if (mapS2.get(key) !== count) return false;
        }
        return true;
    }

    for (let i = 0; i < k; i++) {
        freqMapS1.set(s1[i], (freqMapS1.get(s1[i]) || 0) + 1);
        freqMapS2.set(s2[i], (freqMapS2.get(s2[i]) || 0) + 1);
    }

    // Check first window
    if (isMatched(freqMapS1, freqMapS2)) return true;

    // Slide the window
    for (let i = k; i < s2.length; i++) {
        freqMapS2.set(s2[i], (freqMapS2.get(s2[i]) || 0) + 1);
        const leftChar = s2[i - k];
        freqMapS2.set(leftChar, freqMapS2.get(leftChar) - 1);
        if (freqMapS2.get(leftChar) === 0) freqMapS2.delete(leftChar);

        if (isMatched(freqMapS1, freqMapS2)) return true;
    }

    return false;
};

```

# Complexity
**Time:** O(n * 26) where n = |s2| -- sliding window with O(26) map comparison at each step
**Space:** O(1) -- frequency maps have at most 26 entries
