# Maximum Number of Non-overlapping Palindrome Substrings
[2472. Maximum Number of Non-overlapping Palindrome Substrings](https://leetcode.com/problems/maximum-number-of-non-overlapping-palindrome-substrings/)

You are given a string s and a positive integer k.

Select a set of non-overlapping substrings from the string s that satisfy the following conditions:

The length of each substring is at least k.
Each substring is a palindrome.
Return the maximum number of substrings in an optimal selection.

A substring is a contiguous sequence of characters within a string.

Example 1:

Input: s = "abaccdbbd", k = 3
Output: 2
Explanation: We can select the substrings underlined in s = "abaccdbbd". Both "aba" and "dbbd" are palindromes and have a length of at least k = 3.
It can be shown that we cannot find a selection with more than two valid substrings.
Example 2:

Input: s = "adbcda", k = 2
Output: 0
Explanation: There is no palindrome substring of length at least 2 in the string.
 
Constraints:

1 <= k <= s.length <= 2000
s consists of lowercase English letters.

# Key insights

- **Two-phase approach**: first find all palindrome candidates, then select maximum non-overlapping set
- **Expand around center**: find all palindromes of length ≥ k by expanding from each center (odd and even length)
- **Greedy interval scheduling**: this is a classic problem once we have intervals
  - Sort by end position ascending
  - Greedily select intervals that start after the previous one ends
  - This greedy choice is optimal (earliest deadline first)

# Code
```javascript
var maxPalindromes = function(s, k) {
    const n = s.length;
    const intervals = [];

    // expand around center (l,r) and collect palindromes with length >= k
    function expandAndCollect(l, r) {
        while (l >= 0 && r < n && s[l] === s[r]) {
            if (r - l + 1 >= k) {
                // record interval [l, r]
                intervals.push([l, r]);
            }
            l--;
            r++;
        }
    }

    // odd length centers
    for (let i = 0; i < n; i++) {
        expandAndCollect(i, i);
    }
    // even length centers
    for (let i = 0; i < n - 1; i++) {
        expandAndCollect(i, i + 1);
    }

    if (intervals.length === 0) return 0;

    // sort by end ascending (greedy interval scheduling)
    intervals.sort((a, b) => a[1] - b[1] || a[0] - b[0]);

    let count = 0;
    let lastEnd = -1;
    for (const [start, end] of intervals) {
        if (start > lastEnd) {
            count++;
            lastEnd = end;
        }
    }
    return count;
};
```

# Complexity

- **Time**: O(n² log n) — expand around center is O(n²) to find all palindromes, sorting intervals is O(n² log n) in worst case
- **Space**: O(n²) to store all palindrome intervals in worst case