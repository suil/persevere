# Recover Binary Search Tree
[99. Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/)

You are given the root of a binary search tree (BST), where exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.

Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?

Example 1:

Input: root = [1,3,null,null,2]
Output: [3,1,null,null,2]
Explanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.
Example 2:

Input: root = [3,1,4,null,null,2]
Output: [2,1,4,null,null,3]
Explanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.

# Key insights
* Use inorder traversal to visit BST nodes in sorted order
* Track previous node to detect violations where current < previous
* Identify exactly two swapped nodes during single traversal pass
* Swap the two violating node values to restore BST property

# Code
```javascript
var recoverTree = function(root) {
    var node1, node2;
    var prev = new TreeNode(-Infinity);

    function inOrder(node) {
        if (!node) { return; }
        inOrder(node.left);
        if (node.val < prev.val) {
            node2 = node;
            if (!node1) { node1 = prev; }
        }
        prev = node;
        inOrder(node.right);
    }

    inOrder(root);
    [node1.val, node2.val] = [node2.val, node1.val];
};
```

# Complexity
**Time:** O(n) - performs in-order traversal visiting each node exactly once
**Space:** O(h) - recursive call stack uses space proportional to tree height, where h ranges from log n to n
