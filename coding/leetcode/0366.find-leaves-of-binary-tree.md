# Find Leaves of Binary Tree
[366. Find Leaves of Binary Tree](https://leetcode.com/problems/find-leaves-of-binary-tree/)

Given a binary tree, collect a tree's nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.

Example:
Given binary tree
          1
         / \
        2   3
       / \     
      4   5    
Returns [4, 5, 3], [2], [1].

# Key insights

- **Iterative leaf removal**: each round collects all current leaf nodes (nodes with no children), then removes them by returning `null` from the recursive helper
- **Post-order DFS per round**: traverse left and right subtrees first, then check if the current node has become a leaf after its children are pruned
- The tree structure mutates each round — a node becomes a leaf once both its children are removed
- Repeat until `root` itself is removed (becomes `null`)

# Code
```javascript
var findLeaves = function(root) {
    const res = [];

    function postOrder(node) {
        if (node == null) return -1;
        if (node.left == null && node.right == null) {
            const level = 0;
            if (!res[level]) res[level] = [];
            res[level].push(node.val);
            return level;
        }

        const left = postOrder(node.left);
        const right = postOrder(node.right);

        const level = Math.max(left, right) + 1;
        if (!res[level]) res[level] = [];
        res[level].push(node.val);
        return level
    }

    postOrder(root)
    return res;
};
```

# Complexity

- **Time**: O(n²) — in the worst case (skewed tree), the tree has height n and we do a full traversal each round, resulting in O(n) rounds × O(n) per traversal
- **Space**: O(h) for the recursion stack where h is the tree height, plus O(n) for the result array
