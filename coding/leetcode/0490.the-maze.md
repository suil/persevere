# The Maze
[490. The Maze](https://leetcode.com/problems/the-maze/)

There is a ball in a maze with empty spaces (represented as 0) and walls (represented as 1). The ball can go through the empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.

# Key insights
- The ball rolls continuously in one direction until hitting a wall, so DFS explores stopping positions (not individual cells)
- Use a visited set on stopping positions to avoid revisiting; the ball can only change direction when it stops
- From each stopping position, simulate rolling in all 4 directions using a while loop until the next cell is a wall or boundary

# Code
```javascript
/**
 * @param {number[][]} maze
 * @param {number[]} start
 * @param {number[]} destination
 * @return {boolean}
 */
var hasPath = function(maze, start, destination) {
    
    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
    const visited = new Set();
    const [destRow, destCol] = destination;
    const [startRow, startCol] = start;

    function dfs(currRow, currCol) {
        if (visited.has([currRow, currCol].join('-')) 
            || maze[currRow]?.[currCol] === undefined
            || maze[currRow][currCol] === 1 
        ) {
            return false;
        }
        if (currRow === destRow && currCol === destCol) return true;

        visited.add([currRow, currCol].join('-'));

        for (const [dRow, dCol] of directions) {
            let nextRow = currRow;
            let nextCol = currCol;

            while (maze[nextRow + dRow]?.[nextCol + dCol] !== undefined
                && maze[nextRow + dRow][nextCol + dCol] === 0
            ) {
                nextRow += dRow;
                nextCol += dCol;
            }

            if (dfs(nextRow, nextCol) === true) return true;
        }
        return false;
    }

    return dfs(startRow, startCol);
};
```

# Complexity
**Time:** O(m * n) -- each cell can be a stopping position at most once
**Space:** O(m * n) -- for the visited set and recursion stack
