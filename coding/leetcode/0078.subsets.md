# Subsets (Medium)
[78. Subsets (Medium)](https://leetcode.com/problems/subsets/description/)

Given an integer array nums of unique elements, return all possible 
subsets
 (the power set).

The solution set must not contain duplicate subsets. Return the solution in any order.

 

Example 1:

Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
Example 2:

Input: nums = [0]
Output: [[],[0]]

# Key insights
* Generate subsets by size k from 0 to n using backtracking with combinations
* Use recursive helper to build k-sized combinations with current index tracking
* Backtrack by trying each element from current position to avoid duplicates
* Spread operator creates independent copies to prevent reference issues

# Code
```javascript
var subsets = function(nums) {
    const results = [];
    for (let k = 0; k <= nums.length; k++) {
        const output = [];
        subsetsHelper(nums, k, 0, [], output);
        results.push(...output);
    }
    return results;
};

function subsetsHelper(nums, k, current, combinations, output) {
    if (current >= nums.length || combinations.length === k) {
        if (combinations.length === k) {
            output.push([...combinations])
        }
        return;
    }
    
    for (let i = current; i < nums.length; i++) {
        const nextCurrent = i + 1;
        const nextCombinations = [...combinations, nums[i]];
        subsetsHelper(nums, k, nextCurrent, nextCombinations, output);
    }
}
```

# Complexity
**Time:** O(n * 2^n) - generates all 2^n subsets and each subset creation involves array copying which takes O(n) time in worst case
**Space:** O(n * 2^n) - stores all 2^n subsets in results array, each subset can be up to size n, plus O(n) recursion stack depth
