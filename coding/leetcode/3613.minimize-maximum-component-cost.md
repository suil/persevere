# Minimize Maximum Component Cost
[3613. Minimize Maximum Component Cost](https://leetcode.com/problems/minimize-maximum-component-cost/)

You are given an undirected connected graph with n nodes labeled from 0 to n - 1 and a 2D integer array edges where edges[i] = [ui, vi, wi] denotes an undirected edge between node ui and node vi with weight wi, and an integer k.

# Key insights
*

# Code
```javascript
/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number} k
 * @return {number}
 */
var minCost = function(n, edges, k) {
  // If we may have up to n components, we can remove all edges -> cost 0
  if (k >= n) return 0;

  // Disjoint Set Union (Union-Find) with path compression and size
  class DSU {
    constructor(n) {
      this.parent = new Array(n);
      this.size = new Array(n);
      for (let i = 0; i < n; ++i) { this.parent[i] = i; this.size[i] = 1; }
    }
    find(x) {
      if (this.parent[x] !== x) this.parent[x] = this.find(this.parent[x]);
      return this.parent[x];
    }
    union(a, b) {
      a = this.find(a); b = this.find(b);
      if (a === b) return false;
      // union by size
      if (this.size[a] < this.size[b]) [a, b] = [b, a];
      this.parent[b] = a;
      this.size[a] += this.size[b];
      return true;
    }
  }

  // Collect unique weights and sort them for binary search
  const weights = new Set();
  for (const e of edges) weights.add(e[2]);
  const arr = Array.from(weights).sort((a, b) => a - b);

  // Binary search over sorted unique weights
  let left = 0, right = arr.length - 1;
  let answer = arr[arr.length - 1]; // init with max weight

  // Feasibility check: keep edges with weight <= T, count components
  const feasible = (T) => {
    const dsu = new DSU(n);
    for (const [u, v, w] of edges) {
      if (w <= T) dsu.union(u, v);
    }
    // count distinct roots
    const seen = new Set();
    for (let i = 0; i < n; ++i) seen.add(dsu.find(i));
    return seen.size <= k;
  };

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    const T = arr[mid];
    if (feasible(T)) {
      answer = T;
      right = mid - 1; // try smaller
    } else {
      left = mid + 1; // need larger T
    }
  }

  return answer;
};
```

# Complexity
**Time:**
**Space:**
