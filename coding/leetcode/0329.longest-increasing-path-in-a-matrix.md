# Longest Increasing Path in a Matrix
[329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/)

Given an m x n integers matrix, return the length of the longest increasing path in matrix.

# Key insights
- DFS with memoization: compute longest increasing path starting from each cell
- Only move to neighbors with strictly greater values (ensures no cycles)
- Memoize results since the longest path from a cell is fixed
- Try starting from every cell and take the maximum

# Code
```javascript
/**
 * @param {number[][]} matrix
 * @return {number}
 */
var longestIncreasingPath = function(matrix) {
    const rowLen = matrix.length;
    const colLen = matrix[0].length;

    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0],];
    const memo = Array.from({ length: rowLen }, () => Array(colLen).fill(0));

    function dfs(row, col) {
        if (memo[row][col] !== 0) return memo[row][col];

        let maxLen = 1
        for (const [dRow, dCol] of directions) {
            const nextRow = row + dRow
            const nextCol = col + dCol

            if (nextRow < 0 || nextRow >= rowLen || nextCol < 0 || nextCol >= colLen) continue;

            if (matrix[nextRow][nextCol] > matrix[row][col]) {
                maxLen = Math.max(maxLen, 1 + dfs(nextRow, nextCol, memo));
            }
        }

        memo[row][col] = maxLen;
        return maxLen;
    }

    let maxLen = -Infinity;
    for (let r = 0; r < rowLen; r++) {
        for (let c = 0; c < colLen; c++) {
            maxLen = Math.max(maxLen, dfs(r, c));
        }
    }

    return maxLen;
};
```

# Complexity
**Time:** O(m * n) - each cell is computed exactly once due to memoization
**Space:** O(m * n) - for the memoization table and recursion stack
