# Similar String Groups
[839. Similar String Groups](https://leetcode.com/problems/similar-string-groups/)

DFS:

Union Find:

# Key insights
* Use DFS to find connected components of similar strings
* Mark visited strings as null to avoid revisiting during traversal
* Two strings are similar if they differ in at most 2 character positions
* Graph-based approach where each string is a node connected to similar strings

# Code
```javascript
var numSimilarGroups = function(strs) {
    let count = 0;
    for (let i = 0; i < strs.length; i++) {
        if (strs[i] !== null) {
            dfs(strs, i);
            count++;
        }
    }
    return count;
};

function dfs(strs, i) {
    const s = strs[i];
    strs[i] = null;
    for (let j = 0; j < strs.length; j++) {
        if (i !== j && isSimilar(s, strs[j])) {
            dfs(strs, j);
        }
    }
}

function isSimilar(word1, word2) {
    if (word1 === word2) { return true; }
    if ((word1 || '').length !== (word2 || '').length) { return false; }
    let diff = 0;
    for (let i = 0; i < word1.length; i++) {
        if (word1[i] !== word2[i]) { diff++; }
    }
    return diff <= 2;
}
```
```javascript
var numSimilarGroups = function(strs) {
    const uf = new UnionFind();
    for (let i = 0; i < strs.length; i++) {
        let matchFound = false;
        for (let j = i + 1; j < strs.length; j++) {
            if (isSimilar(strs[i], strs[j])) {
                uf.union(strs[i], strs[j]);
                matchFound = true;
            }   
        }
        if (!matchFound) {
            uf.union(strs[i], strs[i]);
        }
    }
    
    return uf.size;
};

class UnionFind {
    constructor(n) {
        this.roots = {};
    }
    
    find(key) {
        if (!this.roots[key]) { this.roots[key] = key; }
        if (this.roots[key] === key) { return key; }
        this.roots[key] = this.find(this.roots[key]);
        return this.roots[key];
    }
    
    union(u, v) {
        const rootU = this.find(u);
        const rootV = this.find(v);
        if (rootU !== rootV) {
            this.roots[rootV] = this.roots[rootU];
        }
    }
    
    get size() {
        return Object.keys(this.roots).filter(key => key == this.roots[key]).length;
    }
}

function isSimilar(word1, word2) {
    if (word1.length !== word2.length) { return false; }
    let diff = 0;
    for (let i = 0; i < word1.length; i++) {
        if (word1[i] !== word2[i]) { diff++; }
    }
    return diff <= 2;
}
```

# Complexity
**Solution 1:**
**Time:** O(n²m) - For each string, DFS visits all other strings and compares them with isSimilar (O(m) operation), resulting in O(n²m) where n is number of strings and m is string length
**Space:** O(n) - Recursion stack depth can go up to n strings in worst case when all strings form one connected component

**Solution 2:**
**Time:** O(n²m) - Nested loops check all pairs of strings (O(n²)) and each similarity check takes O(m) time, plus Union-Find operations are nearly O(1) with path compression
**Space:** O(nm) - UnionFind stores all strings as keys in the roots HashMap, each string taking O(m) space
