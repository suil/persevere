# Coin Change
[322. Coin Change](https://leetcode.com/problems/coin-change)

Memoization:

DP:

# Key insights
* Uses memoization with Map to cache subproblem results and avoid redundant calculations
* Recursive approach tries each coin denomination and finds minimum coins needed
* Base cases: amount 0 returns 0, invalid states return -1
* Time complexity O(amount * coins) with memoization vs exponential without caching

# Code
```javascript
var coinChange = function(coins, amount, memo = new Map()) {
    if (memo.has(`${coins[0]}-${amount}`)) {
        return memo.get(`${coins[0]}-${amount}`);
    }

    if (amount === 0) {
        return 0;
    }

    if (coins.length === 0 || amount < 0) {
        return -1;
    }

    let min = Infinity;
    for (const coin of coins) {
        let count = coinChange(coins, amount - coin);
        if (count != -1) {
            min = Math.min(min, count + 1);
        }
    }
    const res = min === Infinity ? -1 : min;
    memo.set(`${coins[0]}-${amount}`, res);
    return res;
};

```
```javascript
var coinChange = function(coins, amount) {
    const dp = [...Array(amount + 1)].fill(Infinity);
    dp[0] = 0;
    
    for (const coin of coins) {
        let min = Infinity;
        for (let i = coin; i <= amount; i++) {
            if (i >= coin) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    return dp[amount] === Infinity ? -1 : dp[amount];
};
```

# Complexity
**Solution 1:**
**Time:** O(n^amount) - the recursive solution explores all possible combinations without proper memoization since the memo key only uses coins[0] instead of the full coins array
**Space:** O(amount) - space for the recursion stack depth and minimal memoization storage

**Solution 2:**
**Time:** O(n * amount) - iterates through each coin and for each coin checks all amounts from coin value to target amount
**Space:** O(amount) - uses a DP array of size amount + 1 to store minimum coins needed for each amount
