# Word Search II
[212. Word Search II](https://leetcode.com/problems/word-search-ii/)

Given an m x n board of characters and a list of strings words, return all words on the board.

# Key insights
- Build a trie from all words, then DFS from every cell on the board following trie edges to find matches
- Store the complete word at trie leaf nodes for easy result collection without tracking the path
- Prune: delete trie nodes with no children after visiting to avoid redundant searches in later DFS calls

# Code
```javascript
/**
 * @param {character[][]} board
 * @param {string[]} words
 * @return {string[]}
 */
class TrieNode {
    constructor() {
        this.children = {};
        this.word = null; // store word at the end
    }
}

function buildTrie(words) {
    const root = new TrieNode();
    for (const word of words) {
        let node = root;
        for (const char of word) {
            if (!node.children[char]) {
                node.children[char] = new TrieNode();
            }
            node = node.children[char];
        }
        node.word = word; // mark end of a word
    }
    return root;
}

var findWords = function(board, words) {
    const root = buildTrie(words);
    const result = new Set();
    const rows = board.length;
    const cols = board[0].length;
    const visited = new Set();

    function dfs(r, c, node) {
        const char = board[r][c];
        const child = node.children[char];
        if (!child) return;

        if (child.word) {
            result.add(child.word);
            // child.word = null; // de-duplicate
        }

        visited.add([r, c].join('-'));

        const directions = [[1,0],[0,1],[-1,0],[0,-1]];
        for (const [dr, dc] of directions) {
            const nr = r + dr, nc = c + dc;
            if (board[nr]?.[nc] && !visited.has([nr, nc].join('-'))) {
                dfs(nr, nc, child);
            }
        }

        visited.delete([r, c].join('-')); // backtrack

        if (Object.keys(child.children).length === 0) {
            delete node.children[board[r][c]];
        }
    }

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            dfs(r, c, root);
        }
    }

    return Array.from(result);
};
```

# Complexity
**Time:** O(m * n * 4^L) where L is the max word length, plus O(W * L) for trie construction**Space:** O(W * L) for the trie plus O(m * n) for the visited set
