# IP to CIDR
[751. IP to CIDR](https://leetcode.com/problems/ip-to-cidr/)

An IP address is a formatted 32-bit unsigned integer where each group of 8 bits is printed as a decimal number and the dot character '.' splits the groups.

# Key insights
- A CIDR block of size 2^p must start at an address divisible by 2^p; trailing zeros of the IP determine the max alignment
- Greedily pick the largest valid block size that is both aligned and does not exceed remaining addresses
- Use BigInt for accurate 32-bit bitwise operations since JavaScript floats can lose precision

# Code
```javascript
/**
 * @param {string} ip
 * @param {number} n
 * @return {string[]}
 */
var ipToCIDR = function(ip, n) {
    // Helper function to convert a dotted-decimal IP to a 32-bit integer.
    // We use BigInt to handle the potential for numbers larger than standard 32-bit integers in JavaScript.
    // While IPs are 32-bit, standard JS numbers are 64-bit floats, which can lose precision.
    // BigInt ensures accurate bitwise operations.
    const ipToBigInt = (ipStr) => {
        const parts = ipStr.split('.').map(Number);
        let ipNum = 0n;
        ipNum = (BigInt(parts[0]) << 24n) | (BigInt(parts[1]) << 16n) | (BigInt(parts[2]) << 8n) | BigInt(parts[3]);
        return ipNum;
    };

    // Helper function to convert a 32-bit BigInt to a dotted-decimal IP string.
    const bigIntToIp = (num) => {
        const a = (num >> 24n) & 0xFFn;
        const b = (num >> 16n) & 0xFFn;
        const c = (num >> 8n) & 0xFFn;
        const d = num & 0xFFn;
        return `${a}.${b}.${c}.${d}`;
    };

    let startIp = ipToBigInt(ip);
    let addressesLeft = BigInt(n);
    const result = [];

    while (addressesLeft > 0n) {
        // Find the number of trailing zeros in the binary representation of the current IP.
        // This tells us the maximum power of 2 for a block that can start at this IP.
        // A block of size 2^p must start at an address divisible by 2^p.
        let trailingZeros = 0;
        if (startIp !== 0n) { // Special case for IP 0.0.0.0
            let tempIp = startIp;
            // The `&` operator works on BigInts
            while ((tempIp & 1n) === 0n && trailingZeros < 32) {
                trailingZeros++;
                tempIp >>= 1n;
            }
        } else {
            trailingZeros = 32;
        }

        // Now, find the optimal power of 2 (let's call it p) for the current CIDR block.
        // p must satisfy two conditions:
        // 1. The block size (2^p) must not exceed the remaining addresses (`addressesLeft`).
        // 2. The block size must be alignable with the current IP, which means p <= trailingZeros.
        let p = 0;
        while ((1n << BigInt(p + 1)) <= addressesLeft && (p + 1) <= trailingZeros) {
            p++;
        }
        
        const blockSize = 1n << BigInt(p);
        const prefixLength = 32 - p;
        
        result.push(`${bigIntToIp(startIp)}/${prefixLength}`);
        
        startIp += blockSize;
        addressesLeft -= blockSize;
    }
    
    return result;
};
```

# Complexity
**Time:** O(n) where n is the number of addresses to cover (each iteration covers at least one address)**Space:** O(log n) for the output CIDR blocks
