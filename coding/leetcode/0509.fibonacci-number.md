# Fibonacci Number
[509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number)

memoization:

dp:

# Key insights
* Memoization eliminates redundant recursive calls by caching computed Fibonacci values
* Map data structure provides O(1) lookup/storage for previously calculated results
* Top-down dynamic programming approach with recursive structure
* Reduces time complexity from O(2^n) exponential to O(n) linear

# Code
```javascript
function memoize(n, memo) {
    if (memo.has(n)) {
      return memo.get(n);
    }
    if (n === 0) {
      return 0;
    }
    if (n === 1) {
      return 1;
    }
    const fn = memoize(n - 1, memo) + memoize(n - 2, memo);
    memo.set(n, fn);
    return fn;
}
```
```javascript
var fib = function(n) {
    let dp0 = 0;
    let dp1 = 1;

    for (let i = 2; i <= n; i++) {
      const oldDp1 = dp1;
      dp1 = dp0 + dp1;
      dp0 = oldDp1;
    }
    return dp1;
}
```

# Complexity
**Solution 1:**
**Time:** O(n) - Each Fibonacci number from 0 to n is calculated exactly once due to memoization.
**Space:** O(n) - The memo Map stores n+1 values and the recursive call stack has maximum depth of n.

**Solution 2:**
**Time:** O(n) - Single loop iterates from 2 to n, performing constant work each iteration.
**Space:** O(1) - Only uses two variables to store previous Fibonacci numbers, independent of input size.
