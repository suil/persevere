# Time Based Key-Value Store
[981. Time Based Key-Value Store](https://leetcode.com/problems/time-based-key-value-store/)

Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.

Implement the TimeMap class:
- `TimeMap()` Initializes the object.
- `void set(String key, String value, int timestamp)` Stores the key with the value at the given timestamp.
- `String get(String key, int timestamp)` Returns a value such that set was called previously, with timestamp_prev <= timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns "".

Example 1:

Input: ["TimeMap", "set", "get", "get", "set", "get"]
       [[], ["foo", "bar", 1], ["foo", 1], ["foo", 3], ["foo", "bar2", 4], ["foo", 4]]
Output: [null, null, "bar", "bar", null, "bar2"]

Constraints:

1 <= key.length, value.length <= 100
key and value consist of lowercase English letters and digits.
1 <= timestamp <= 10^7
All the timestamps of set are strictly increasing.
At most 2 * 10^5 calls will be made to set and get.

# Key insights

- Timestamps in `set` are **strictly increasing**, so the values list for each key is already sorted by timestamp — no need to sort
- `get` needs the largest timestamp ≤ the query timestamp — this is a classic **binary search** (upper bound) problem
- Use a **Map** where each key maps to an array of `[timestamp, value]` pairs
- Binary search for the rightmost entry with `timestamp <= target`; if none exists, return `""`

# Code
```javascript
var TimeMap = function() {
    this.map = new Map();
};

TimeMap.prototype.set = function(key, value, timestamp) {
    if (!this.map.has(key)) this.map.set(key, []);
    this.map.get(key).push([timestamp, value]);
};

TimeMap.prototype.get = function(key, timestamp) {
    if (!this.map.has(key)) return "";
    const arr = this.map.get(key);

    let left = 0, right = arr.length - 1;
    let res = "";
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (arr[mid][0] <= timestamp) {
            res = arr[mid][1];
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return res;
};
```
# Complexity

- **set**: O(1) — append to the end of the array
- **get**: O(log n) — binary search over the timestamps for the given key, where n is the number of entries for that key
- **Space**: O(total calls to set) — each set call stores one entry
