# Minimum Window Substring
[76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)

Given two strings s and t, return the minimum window in s which will contain all the characters in t. If there is no such window in s that covers all characters in t, return the empty string "".

Note that If there is such a window, it is guaranteed that there will always be only one unique minimum window in s.

Example 1:
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"

Example 2:
Input: s = "a", t = "a"
Output: "a"

# Key insights
* Uses sliding window with two pointers to find minimum valid substring efficiently
* HashMap tracks character frequencies and remaining matches with a global counter
* Expands right pointer to find valid window, contracts left to minimize length
* Counter optimization avoids recalculating validity by tracking required matches

# Code
```javascript
var minWindow = function(s, t) {
    const map = new Map();
    let left = 0;
    let minLen = Infinity;
    let res = '';

    const mapT = new Map();
    for (let i = 0; i < t.length; i++) {
        mapT.set(t[i], (mapT.get(t[i]) || 0) + 1);
    }

    function isValid(map) {
        for (const [char, count] of mapT) {
            if (count > (map.get(char) || 0)) return false;
        }
        return true;
    }

    for (let right = 0; right < s.length; right++) {
        const rightChar = s[right];
        map.set(rightChar, (map.get(rightChar) || 0) + 1);
        while (left <= right && isValid(map)) {
            const leftChar = s[left];
            map.set(leftChar, map.get(leftChar) - 1);
            if (map.get(leftChar) === 0) map.delete(leftChar);
            
            const currLen = right - left + 1;
            if (currLen < minLen) {
                res = s.substring(left, right + 1);
                minLen = currLen;
            }
            left++;
        }
    }

    return res;
};
```

# Complexity
**Time:** O(|s| + |t|) - Each character in string s is visited at most twice (once by right pointer, once by left pointer) and we iterate through t once to build the map
**Space:** O(|t|) - The map stores at most all unique characters from string t, and other variables use constant space
