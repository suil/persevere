# Non-decreasing Subsequences
[491. Non-decreasing Subsequences](https://leetcode.com/problems/non-decreasing-subsequences/)

Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.

# Key insights
- Use backtracking with pick/skip decisions at each index; only pick an element if it is >= the previous element in the path
- Deduplicate results using a Set with stringified paths, since the array is not sorted and standard skip-duplicates tricks do not apply
- Only add subsequences of length >= 2 to the output

# Code
```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var findSubsequences = function(nums) {
    const seen = new Set();
    function backtrack(currIndex, prevNum, path, output) {
        if (currIndex >= nums.length) {
            if (path.length >= 2) {
                const key = path.join(',');
                if (!seen.has(key)) {
                    output.push([...path]);
                    seen.add(key);
                }
            }
            return
        }


        // pick it
        if (prevNum <= nums[currIndex]) {
            backtrack(currIndex + 1, nums[currIndex], [...path, nums[currIndex]], output);
        }

        // not pick it
        backtrack(currIndex + 1, prevNum, [...path], output);
    }

    const output = [];
    backtrack(0, -Infinity, [], output);
    return output;
};
```

# Complexity
**Time:** O(2^n * n) -- up to 2^n subsequences, each taking O(n) to copy and hash
**Space:** O(2^n * n) -- for storing all valid subsequences and the seen set
