# Count the Number of Infection Sequences
[2954. Count the Number of Infection Sequences](https://leetcode.com/problems/count-the-number-of-infection-sequences/)

You are given an integer n and an array sick sorted in increasing order, representing positions of infected children in a line of n children. Each second, an uninfected child adjacent to an infected child becomes infected.

Return the number of possible infection sequences modulo 10^9 + 7.

# Key insights
* The gaps between infected children form independent segments that can be interleaved
* A gap of length g between two infected positions has 2^(g-1) internal orderings (can infect from either side)
* Edge gaps (before first sick or after last sick) have only 1 ordering (must infect from one direction)
* Use multinomial coefficient to count interleavings of all segments, multiplied by each segment's internal orderings
* Precompute factorials and inverse factorials for modular arithmetic

# Code
```javascript
var numberOfSequence = function(n, sick) {
    const MOD = 1e9 + 7;
    
    // Mark sick children
    const isSick = new Array(n).fill(false);
    for (const s of sick) {
        isSick[s] = true;
    }
    
    // Get children that can be infected (adjacent to sick)
    const getInfectible = (sickStatus) => {
        const infectible = [];
        for (let i = 0; i < n; i++) {
            if (!sickStatus[i]) {
                // Check if adjacent to any sick child
                if ((i - 1 >= 0 && sickStatus[i - 1]) || 
                    (i + 1 < n && sickStatus[i + 1])) {
                    infectible.push(i);
                }
            }
        }
        return infectible;
    };
    
    const backtrack = (currentSick) => {
        const infectible = getInfectible(currentSick);
        
        // Base case: no more children to infect
        if (infectible.length === 0) {
            return 1;
        }
        
        let total = 0;
        
        // Try infecting each possible child
        for (const child of infectible) {
            // Infect this child
            // currentSick[child] = true;
            const nextSick = [...currentSick];
            nextSick[child] = true;
            // Recurse
            // total = (total + backtrack(currentSick)) % MOD;
            total = total + backtrack(nextSick);
            // Backtrack
            // currentSick[child] = false;
        }
        
        return total;
    };
    
    return backtrack([...isSick]);
};
```

# Complexity
**Time:** O(n) - Precomputing factorials and processing each gap.
**Space:** O(n) - For the factorial array.
