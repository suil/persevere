# Number of Longest Increasing Subsequence
[673. Number of Longest Increasing Subsequence](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)

Given an integer array nums, return the number of longest increasing subsequences.

# Key insights
- Two DP arrays: `dp[i]` stores the length of the LIS ending at index i, `countDp[i]` stores the number of such LIS
- When extending from j to i: if a longer subsequence is found, reset count; if same length, accumulate count
- After filling DP, sum countDp[i] for all indices where dp[i] equals the global maximum LIS length

# Code
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findNumberOfLIS = function(nums) {
    if (!nums || nums.length === 0) {
        return 0;
    }

    // let maxLen = 0;
    // let count = 0;

    // function dfs(index, subsequences, output) {
    //     if (index === nums.length) {
    //         if (subsequences.length > maxLen) {
    //             maxLen = subsequences.length;
    //             count = 1;
    //         } else if (subsequences.length === maxLen && maxLen > 0) {
    //             count++;
    //         }
    //         return;
    //     }

    //     // not taken
    //     dfs(index + 1, subsequences, output);

    //     // taken
    //     if (subsequences.length === 0 || nums[index] > subsequences[subsequences.length - 1]) {
    //         dfs(index + 1, [...subsequences, nums[index]], output);
    //     }
    // }

    // const output = []
    // dfs(0, [], output);
    // return count;

    const dp = Array(nums.length).fill(1);
    const countDp = Array(nums.length).fill(1);
    
    let maxLen = 1;
    for (let i = 1; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                if (dp[i] < dp[j] + 1) {
                    dp[i] = dp[j] + 1;
                    countDp[i] = countDp[j]; // reset counter.
                } else if (dp[j] + 1 === dp[i]) {
                    countDp[i] += countDp[j]; // update counter
                }
            }
        }
        maxLen = Math.max(maxLen, dp[i]);
    }
console.log(maxLen)
console.log(dp);
console.log(countDp);
    let count = 0;
    for (let i = 0; i < nums.length; i++) {
        if (dp[i] === maxLen) count += countDp[i];
    }
    return count;
};
```

# Complexity
**Time:** O(n^2) -- nested loops comparing all pairs
**Space:** O(n) -- for the dp and countDp arrays
