# Lowest Common Ancestor of a Binary Tree III
[1650. Lowest Common Ancestor of a Binary Tree III](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/)

using two pointers:

Set:

# Key insights
* Two-pointer technique with cyclic traversal to handle different path lengths
* Switch to other node's starting point when reaching null to synchronize paths
* No extra space needed - uses parent pointers to traverse upward
* Guarantees meeting at LCA due to equal total distance after path switching

# Code
```javascript
var lowestCommonAncestor = function(p, q) {
    let nodeA = p;
    let nodeB = q; 
    while (nodeA !== nodeB) {
        nodeA = nodeA === null ? q : nodeA.parent;
        nodeB = nodeB === null ? p : nodeB.parent;        
    }
    return nodeA;
};
```
```javascript
var lowestCommonAncestor = function(p, q) {
    const set = new Set();
    while (p !== null) {
        set.add(p);
        p = p.parent;
    }
    while (q !== null) {
        if (set.has(q)) {
            return q;
        }
        q = q.parent;
    }
    return null;
};
```

# Complexity
**Solution 1:**
**Time:** O(h) - Both pointers traverse at most 2h nodes where h is the height of the tree
**Space:** O(1) - Only uses two pointer variables regardless of input size

**Solution 2:**
**Time:** O(h) - Traverses from p to root once, then from q upward until finding common ancestor
**Space:** O(h) - Uses a set to store all ancestors of p from node to root
