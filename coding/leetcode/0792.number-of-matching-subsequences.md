# Number of Matching Subsequences
[792. Number of Matching Subsequences](https://leetcode.com/problems/number-of-matching-subsequences/)

Given a string s and an array of strings words, return the number of words[i] that is a subsequence of s.

# Key insights
- Preprocess string s into a map of character to sorted list of indices for O(1) character lookup
- For each word, use binary search to find the next occurrence of each character after the current position in s
- Binary search on the index list avoids scanning s repeatedly, making each word check O(L * log |s|)

# Code
```javascript
/**
 * @param {string} s
 * @param {string[]} words
 * @return {number}
 */
const numMatchingSubseq = (s, words) => {
    // 1. Preprocessing: Create a map of character indices
    const indicesMap = new Map();
    for (let i = 0; i < s.length; i++) {
        const char = s[i];
        if (!indicesMap.has(char)) {
            indicesMap.set(char, []);
        }
        indicesMap.get(char).push(i);
    }

    // Helper function for binary search
    const findNextIndex = (arr, lastIndex) => {
        let left = 0;
        let right = arr.length - 1;
        let result = -1;

        while (left <= right) {
            const mid = Math.floor((left + right) / 2);
            if (arr[mid] > lastIndex) {
                result = arr[mid];
                right = mid - 1; // Look for an even smaller index
            } else {
                left = mid + 1; // Need a larger index
            }
        }
        return result;
    };

    let count = 0;
    // 2. Process each word
    for (const word of words) {
        let lastIndex = -1;
        let isMatch = true;

        for (const char of word) {
            if (!indicesMap.has(char)) {
                isMatch = false;
                break;
            }

            const indices = indicesMap.get(char);
            const nextIndex = findNextIndex(indices, lastIndex);

            if (nextIndex === -1) {
                isMatch = false;
                break;
            }
            lastIndex = nextIndex;
        }

        if (isMatch) {
            count++;
        }
    }

    return count;
};

```

# Complexity
**Time:** O(|s| + sum of word lengths * log |s|)
**Space:** O(|s|) for the indices map
