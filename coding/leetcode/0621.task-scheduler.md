# Task Scheduler
[621. Task Scheduler](https://leetcode.com/problems/task-scheduler/)

# Key insights
* Count task frequencies and sort to identify the most frequent task
* Calculate idle slots based on max frequency task creating the scheduling framework
* Fill idle time with remaining tasks to minimize total execution time
* Greedy approach: prioritize high-frequency tasks to reduce cooling periods

# Code
```javascript
/**
 * @param {character[]} tasks
 * @param {number} n
 * @return {number}
 */
var leastInterval = function(tasks, n) {
    const freqMap = new Map();
    for (const task of tasks) {
        freqMap.set(task, (freqMap.get(task) || 0) + 1);
    }

    const pq = new PriorityQueue((a, b) => b.count - a.count);
    for (const [task, count] of freqMap) {
        pq.push({ task, count });
    }

    let numOfCpu = 0;
    while (!pq.isEmpty()) {
        const cycle = [];
        
        for (let i = 0; i < n + 1; i++) {
            if (!pq.isEmpty()) {
                const item = pq.pop();
                cycle.push(item);
            }
        }

        for (const item of cycle) {
            item.count--;
            if (item.count > 0) pq.push(item);
        }

        numOfCpu += pq.isEmpty() ? cycle.length : n + 1;
    }
    return numOfCpu;
};
```

# Complexity
**Solution 1:**
**Time:** O(T) - iterate through tasks once to count frequencies, then sort 26 elements which is O(1)
**Space:** O(1) - uses fixed-size array of 26 elements for task frequencies
