# Maximum Length of Repeated Subarray
[718. Maximum Length of Repeated Subarray](https://leetcode.com/problems/maximum-length-of-repeated-subarray/)

Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.

# Key insights
- 2D DP where dp[i][j] represents the length of the longest common subarray ending at nums1[i-1] and nums2[j-1]
- If nums1[i-1] == nums2[j-1], extend the match from dp[i-1][j-1]; otherwise dp[i][j] remains 0 (subarrays must be contiguous)
- Track the global maximum across all dp entries

# Code
```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findLength = function(nums1, nums2) {
    
    let maxLen = 0;
    // function backtrack(p1, p2, maxLen) {
    //     if (p1 >= nums1.length || p2 >= nums2.length) return 0;

    //     let takenLen = 0;
    //     if (nums1[p1] === nums2[p2]) {
    //         takenLen = 1 + backtrack(p1 + 1, p2 + 1);
    //         maxLen = Math.max(maxLen, takenLen);
    //     }
    //     backtrack(p1 + 1, p2, maxLen);
    //     backtrack(p1, p2 + 1, maxLen);
    //     return takenLen;
    // }

    // backtrack(0, 0);
    // return maxLen;

    const dp = Array(nums1.length + 1).fill().map(() => Array(nums2.length + 1).fill(0));
    dp[0][0] = 0;

    for (let i = 1; i <= nums1.length; i++) {
        for (let j = 1; j <= nums2.length; j++) {
            if (nums1[i - 1] === nums2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            }
            maxLen = Math.max(maxLen, dp[i][j]);
        }
    }
    return maxLen;
}
```

# Complexity
**Time:** O(m * n) where m and n are the lengths of the two arrays
**Space:** O(m * n) -- for the 2D DP table
