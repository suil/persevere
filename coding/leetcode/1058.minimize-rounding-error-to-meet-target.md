# Minimize Rounding Error to Meet Target
[1058. Minimize Rounding Error to Meet Target](https://leetcode.com/problems/minimize-rounding-error-to-meet-target/)

Given an array of prices [p1,p2...,pn] and a target, round each price pi to Roundi(pi) so that the rounded array [Round1(p1),Round2(p2)...,Roundn(pn)] sums to the given target. Each operation Roundi(pi) could be either Floor(pi) or Ceil(pi).

# Key insights
- Uses memoized DFS to explore all combinations of rounding each price up or down
- At each index, branches into floor and ceil options, accumulating the rounding error
- Memoizes on (index, sumSoFar) to avoid recomputing overlapping subproblems

# Code
```javascript
/**
 * @param {string[]} prices
 * @param {number} target
 * @return {string}
 */
var minimizeError = function(prices, target) {
    const n = prices.length;
    const nums = prices.map(parseFloat);
    const memo = new Map();

    function dfs(index, sumSoFar) {
        if (index === n) {
            return sumSoFar === target ? 0 : Infinity;
        }

        const key = `${index},${sumSoFar}`;
        if (memo.has(key)) return memo.get(key);

        const num = nums[index];
        const floorVal = Math.floor(num);
        const ceilVal = Math.ceil(num);

        let minError = Infinity;

        // Option 1: round down
        let err1 = dfs(index + 1, sumSoFar + floorVal);
        if (err1 !== Infinity) {
            err1 += Math.abs(num - floorVal);
            minError = Math.min(minError, err1);
        }

        // Option 2: round up (only if not already an integer)
        if (floorVal !== ceilVal) {
            let err2 = dfs(index + 1, sumSoFar + ceilVal);
            if (err2 !== Infinity) {
                err2 += Math.abs(num - ceilVal);
                minError = Math.min(minError, err2);
            }
        }

        memo.set(key, minError);
        return minError;
    }

    const result = dfs(0, 0);
    return result === Infinity ? "-1" : result.toFixed(3);
};
```

# Complexity
**Time:** O(n * target) -- n prices with sum values up to target
**Space:** O(n * target) -- for the memoization map
