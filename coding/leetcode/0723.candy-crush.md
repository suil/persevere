# Candy Crush
[723. Candy Crush](https://leetcode.com/problems/candy-crush/)

This question is about implementing a basic elimination algorithm for Candy Crush.

# Key insights
- Simulate the game loop: repeatedly mark, crush, and drop until no more crushable candies exist
- Use a separate boolean crush matrix to mark all cells to be removed in each pass, allowing simultaneous horizontal and vertical detection
- Gravity is applied per column by writing non-zero values from bottom up, then filling remaining top cells with zeros

# Code
```javascript
/**
 * @param {number[][]} board
 * @return {number[][]}
 */
var candyCrush = function(board) {
    const rows = board.length;
    const cols = board[0].length;
    let changed = false;

    do {
        changed = false;
        const crush = Array.from({ length: rows }, () => Array(cols).fill(false));

        // Mark candies to be crushed horizontally
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols - 2; c++) {
                const val = Math.abs(board[r][c]);
                if (val !== 0 && val === Math.abs(board[r][c + 1]) && val === Math.abs(board[r][c + 2])) {
                    crush[r][c] = crush[r][c + 1] = crush[r][c + 2] = true;
                    changed = true;
                }
            }
        }

        // Mark candies to be crushed vertically
        for (let c = 0; c < cols; c++) {
            for (let r = 0; r < rows - 2; r++) {
                const val = Math.abs(board[r][c]);
                if (val !== 0 && val === Math.abs(board[r + 1][c]) && val === Math.abs(board[r + 2][c])) {
                    crush[r][c] = crush[r + 1][c] = crush[r + 2][c] = true;
                    changed = true;
                }
            }
        }

        // Crush marked candies
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if (crush[r][c]) {
                    board[r][c] = 0;
                }
            }
        }

        // Drop candies
        for (let c = 0; c < cols; c++) {
            let writeRow = rows - 1;
            for (let r = rows - 1; r >= 0; r--) {
                if (board[r][c] !== 0) {
                    board[writeRow][c] = board[r][c];
                    writeRow--;
                }
            }
            // Fill the rest with 0s
            for (let r = writeRow; r >= 0; r--) {
                board[r][c] = 0;
            }
        }

    } while (changed);

    return board;
};
```

# Complexity
**Time:** O((R * C)^2) in the worst case, where each pass is O(R * C) and there can be O(R * C) passes**Space:** O(R * C) for the crush marking matrix
