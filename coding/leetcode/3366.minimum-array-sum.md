# Minimum Array Sum
[3366. Minimum Array Sum](https://leetcode.com/problems/minimum-array-sum/)

You are given an integer array nums and three integers k, op1, and op2.

You can perform the following operations on nums:
- **Operation 1:** Pick an index i and divide nums[i] by 2, rounding up. You can perform this operation at most op1 times, and at most once per index.
- **Operation 2:** Pick an index i and subtract k from nums[i], but only if nums[i] >= k. You can perform this operation at most op2 times, and at most once per index.

Both operations can be applied to the same index, but each at most once.

Return the minimum possible sum of all elements in nums after performing any number of operations.

# Key insights
* This is a DP problem where for each element we decide: no op, op1 only, op2 only, or both (op1 then op2, or op2 then op1)
* Order of operations on the same element matters â€” try both orderings and take the minimum
* Top-down DP state: `dfs(index, remainingOp1, remainingOp2)` = min sum from index onward
* For each element, compute the result of all valid operation combinations and recurse

# Code
```javascript
var minArraySum = function(nums, k, op1, op2) {

    function backtrack(i, o1, o2, memo = {}) {
        if (i === nums.length) return 0;
        const memoKey = `${i}-${o1}-${o2}`;
        if (memoKey in memo) return memo[memoKey];

        let val = nums[i];
        
        // Option 0: Do nothing
        let res = val + backtrack(i + 1, o1, o2, memo);

        // Option 1: Apply only Op1
        if (o1 > 0) {
            let nextVal = Math.ceil(val / 2);
            res = Math.min(res, nextVal + backtrack(i + 1, o1 - 1, o2, memo));
        }

        // Option 2: Apply only Op2
        if (o2 > 0 && val >= k) {
            let nextVal = val - k;
            res = Math.min(res, nextVal + backtrack(i + 1, o1, o2 - 1, memo));
        }

        // Option 3: Apply Both (Op1 then Op2 OR Op2 then Op1)
        if (o1 > 0 && o2 > 0) {
            // Path A: Op1 then Op2
            let res1 = Math.ceil(val / 2);
            if (res1 >= k) {
                res = Math.min(res, (res1 - k) + backtrack(i + 1, o1 - 1, o2 - 1, memo));
            }

            // Path B: Op2 then Op1
            if (val >= k) {
                let res2 = Math.ceil((val - k) / 2);
                res = Math.min(res, res2 + backtrack(i + 1, o1 - 1, o2 - 1, memo));
            }
        }

        return memo[memoKey] = res;
    };

    return backtrack(0, op1, op2);
};
```

# Complexity
**Time:** O(n * op1 * op2) - Each unique state (index, op1, op2) is computed once.
**Space:** O(n * op1 * op2) - Memoization table storing all computed states, plus recursion stack of depth n.
