# Optimal Account Balancing
[465. Optimal Account Balancing](https://leetcode.com/problems/optimal-account-balancing/)

You are given an array of transactions transactions where transactions[i] = [fromi, toi, amounti] indicates that the person with ID = fromi gave amounti $ to the person with ID = toi.

# Key insights
- Reduce transactions to net balances per person, then filter out zero-balance entries
- Use backtracking to settle debts: for each unsettled debt, try pairing it with an opposite-sign debt and recurse to find the minimum number of transactions
- Only pair debts with opposite signs (product < 0) since settling same-sign debts is wasteful

# Code
```javascript
/**
 * @param {number[][]} transactions
 * @return {number}
 */
var minTransfers = function(transactions) {
    const balance = {};

    for (const [from, to, amount] of transactions) {
        balance[from] = (balance[from] || 0) - amount;
        balance[to] = (balance[to] || 0) + amount;
    }

    const debts = Object.values(balance).filter(v => v !== 0);

    function backtrack(index) {
        while (index < debts.length && debts[index] === 0) index++;
        if (index >= debts.length) return 0;
        
        let min = Infinity;
        for (let i = index + 1; i < debts.length; i++) {
            if (debts[index] * debts[i] < 0) {
                debts[i] += debts[index];
                min = Math.min(min, 1 + backtrack(index + 1));
                debts[i] -= debts[index];
            }
        }
        return min === Infinity ? 0 : min;
    }

    return backtrack(0);
};

```

# Complexity
**Time:** O(n!) -- backtracking over all permutations of non-zero debts in the worst case
**Space:** O(n) -- recursion depth proportional to the number of non-zero debts
