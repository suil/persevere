# Number of Connected Components in an Undirected Graph
[323. Number of Connected Components in an Undirected Graph](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/)

DFS

Union Find

# Key insights
* Build adjacency list representation from edge list for efficient graph traversal
* Use DFS to explore all nodes in each connected component recursively
* Track visited nodes with Set to avoid revisiting and infinite loops
* Count components by incrementing counter for each new DFS traversal started

# Code
```javascript
var countComponents = function(n, edges) {
    const graph = [...Array(n)].map(() => []);
    for (const [u, v] of edges) {
        graph[u].push(v);
        graph[v].push(u);
    }
    
    const visited = new Set();
    let count = 0;
    for (let i = 0; i < n; i++) {
        if (!visited.has(i)) {
            dfs(graph, i, visited);
            count++;
        }
    }
    return count;
};

function dfs(graph, current, visited) {
    visited.add(current);
    const neighbors = graph[current] || [];
    for (const neighbor of neighbors) {
        if (!visited.has(neighbor)) {
            dfs(graph, neighbor, visited);
        }
    }
}
```
```javascript
var countComponents = function(n, edges) {
    const uf = new UnionFind(n);
    for (const [u, v] of edges) {
        uf.union(u, v);
    }
    return uf.size;
};
class UnionFind {
    constructor(n) {
        this.roots = [...Array(n)].map((_, i) => i);
        this.length = n;
    }
    
    find(id) {
        if (this.roots[id] === id) {
            return id;
        }
        this.roots[id] = this.find(this.roots[id]);
        return this.roots[id];
    }
    
    union(a, b) {
        const rootA = this.find(a);
        const rootB = this.find(b);
        if (rootA !== rootB) {
            this.roots[rootB] = rootA;
            this.length--;
        }
    }
    
    get size() {
        return this.length;
    }
}
```

# Complexity
**Solution 1:**
**Time:** O(V + E) - DFS visits each vertex once and traverses each edge twice (once from each endpoint)
**Space:** O(V + E) - adjacency list stores all edges and visited set can store all vertices, plus O(V) recursion stack depth

**Solution 2:**
**Time:** O(E × α(V)) - processes E edges, each union/find operation takes nearly constant amortized time due to path compression
**Space:** O(V) - Union-Find structure stores parent array of size V
