# Find if Path Exists in Graph
[1971. Find if Path Exists in Graph](https://leetcode.com/problems/find-if-path-exists-in-graph/description/)

dfs:

bfs:

# Key insights
* Uses DFS recursive traversal to explore all possible paths from source to destination
* Maintains visited array to prevent infinite cycles in undirected graph
* Early termination when destination is found optimizes performance
* Adjacency list representation enables efficient neighbor traversal

# Code
```javascript
function dfs(graph, current, visited, destination) {
    if (current === destination) {
        return true;
    }
    if (visited[current] === true) {
        return false;
    }
    visited[current] = true;
    for (const node of graph[current]) {
        if (dfs(graph, node, visited, destination) === true) {
            return true;
        }
    }
    return false;
}
```
```javascript
function bfs(graph, visited, source, destination) {
    let queue = [source];
    
    while (queue.length > 0) {
       const nextQueue = [];
       for (const node of queue) {
           if (visited[node]) {
               continue;
           }
           if (node === destination) {
               return true;
           }
           visited[node] = true;
           const neighbors = graph[node];
           nextQueue.push(...neighbors);
       }
       queue = nextQueue;
    }

    return false;
}
```

# Complexity
**Solution 1 (DFS):**
**Time:** O(V + E) - visits each vertex once and traverses each edge once in worst case
**Space:** O(V) - recursion stack can go up to V deep plus visited array of size V

**Solution 2 (BFS):**
**Time:** O(V + E) - visits each vertex once and processes each edge once in worst case
**Space:** O(V) - queue can contain up to V vertices plus visited array of size V
