# Degree of an Array
[697. Degree of an Array](https://leetcode.com/problems/degree-of-an-array/)

Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.

Your task is to find the smallest possible length of a contiguous subarray of nums that has the same degree as nums.

Example 1:

Input: nums = [1,2,2,3,1]
Output: 2
Explanation: The degree is 2 (elements 1 and 2 each appear twice). The shortest subarray with degree 2 is [2,2], length 2.
Example 2:

Input: nums = [1,2,2,3,1,4,2]
Output: 6
Explanation: The degree is 3 (element 2 appears 3 times). The shortest subarray is [2,2,3,1,4,2], length 6.

Constraints:

nums.length will be between 1 and 50,000.
nums[i] will be an integer between 0 and 49,999.

# Key insights

- The minimum subarray with the same degree must span from the **first to the last occurrence** of some element with maximum frequency
- In a single pass, track three things per element: **frequency**, **first index**, **last index**
- Compute the degree (max frequency), then among all elements with that frequency, return the minimum span: `last[n] - first[n] + 1`
- No need to generate or examine actual subarrays

# Code
```javascript
var findShortestSubArray = function(nums) {
    const count = {}, first = {}, last = {};

    for (let i = 0; i < nums.length; i++) {
        const n = nums[i];
        count[n] = (count[n] || 0) + 1;
        if (first[n] === undefined) first[n] = i;
        last[n] = i;
    }

    const degree = Math.max(...Object.values(count));
    let res = nums.length;

    for (const n in count) {
        if (count[n] === degree) {
            res = Math.min(res, last[n] - first[n] + 1);
        }
    }

    return res;
};
```
# Complexity

- **Time**: O(n) â€” one pass to build the maps, one pass over unique elements (at most n)
- **Space**: O(k) where k is the number of unique elements in nums
