# First Missing Positive
[41. First Missing Positive](https://leetcode.com/problems/first-missing-positive/)

Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.

# Key insights
- Cyclic sort: place each value x into index x-1 so that nums[i] should equal i+1
- Swap nums[i] to its correct position repeatedly until no more valid placements can be made
- After sorting, the first index where nums[i] != i+1 gives the answer; if all match, return n+1

# Code
```javascript
/**
 * LeetCode 41: First Missing Positive
 * O(n) time, O(1) extra space (in-place cyclic placement)
 *
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function(nums) {
    const n = nums.length;

    // Place each number x in position x-1 if 1 <= x <= n
    for (let i = 0; i < n; i++) {
        while (
            nums[i] >= 1 &&
            nums[i] <= n &&
            nums[nums[i] - 1] !== nums[i]
        ) {
            const correctIdx = nums[i] - 1;
            [nums[i], nums[correctIdx]] = [nums[correctIdx], nums[i]];
        }
    }

    // The first index i where nums[i] != i+1 gives the answer i+1
    for (let i = 0; i < n; i++) {
        if (nums[i] !== i + 1) return i + 1;
    }

    // If all positions are correct, the missing positive is n+1
    return n + 1;
};
```

# Complexity
**Time:** O(n)
**Space:** O(1)
