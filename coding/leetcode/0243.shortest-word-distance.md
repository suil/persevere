# Shortest Word Distance
[243. Shortest Word Distance](https://leetcode.com/problems/shortest-word-distance/)

Hashmap Solution:

One pass:

# Key insights
* Map each word to array of indices for efficient position lookup
* Two-pointer technique to find minimum distance between sorted position arrays
* Always advance pointer with smaller position to explore all combinations
* O(m + n) traversal of positions avoids nested loops for better efficiency

# Code
```javascript
var shortestDistance = function(wordsDict, word1, word2) {
    const map = new Map();
    for (let i = 0; i < wordsDict.length; i++) {
        const word = wordsDict[i];
        if (!map.has(word)) { map.set(word, []); }
        map.get(word).push(i);
    }
    
    const positions1 = map.get(word1);
    const positions2 = map.get(word2);
    
    let index1 = 0;
    let index2 = 0;
    
    let min = Infinity;
    while (index1 < positions1.length && index2 < positions2.length) {
        const position1 = positions1[index1];
        const position2 = positions2[index2];
        min = Math.min(min, Math.abs(position1 - position2));
        
        if (position1 < position2) {
            index1++;
        } else {
            index2++;
        }
    }
    return min;
};
```
```javascript
var shortestDistance = function(wordsDict, word1, word2) {
    let p1 = null, p2 = null;
    const same = word1 === word2;
    let min = Infinity;
    for (let i = 0; i < wordsDict.length; i++) {
        if (wordsDict[i] === word1) { p1 = i; }
        if (wordsDict[i] === word2) { p2 = i; }
        if (p1 !== null && p2 !== null) {
            min = Math.min(min, Math.abs(p1 - p2));
        }
    }
    return min;
}
```

# Complexity
**Solution 1:**
**Time:** O(n) - We iterate through the array once to build the map, then use two pointers to find minimum distance in O(k1 + k2) where k1, k2 are occurrences of each word
**Space:** O(n) - We store all word positions in a hash map which could contain all n elements in worst case

**Solution 2:**
**Time:** O(n) - Single pass through the array, updating positions and minimum distance as we encounter target words
**Space:** O(1) - Only using constant extra space to store two position variables and minimum distance
