# Binary Tree Postorder Traversal
[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)

Recursive

Non-recursive

# Key insights
* Recursive divide-and-conquer traverses left subtree, then right subtree, then processes root
* Uses array spread operator to concatenate results from left and right recursive calls
* Base case returns empty array when node is null to handle leaf node children
* Space complexity O(h) for recursion stack where h is tree height

# Code
```javascript
var postorderTraversal = function(root) {
    return postorderTraversalHelper(root)
};
function postorderTraversalHelper(node) {
    if (node === null) {
        return [];
    }
    return [
        ...postorderTraversalHelper(node.left),
        ...postorderTraversalHelper(node.right),
        node.val
    ]
}
```
```javascript
var postorderTraversal = function(root) {
    const res = [];
    const stack = [root];
    while (stack.length > 0) {
        const node = stack.pop();
        if (node === null) { continue; }
        res.unshift(node.val);
        stack.push(node.left);
        stack.push(node.right);
    }
    return res;
};
```

# Complexity
**Solution 1:**
**Time:** O(n²) - visits each node once but spread operator creates new arrays at each level, causing quadratic behavior in worst case
**Space:** O(n²) - recursive call stack uses O(h) space but spread operations create multiple intermediate arrays totaling O(n²) space

**Solution 2:**
**Time:** O(n²) - visits each node once but unshift operation is O(n) for each of the n nodes
**Space:** O(n) - uses explicit stack and result array, both bounded by tree size
