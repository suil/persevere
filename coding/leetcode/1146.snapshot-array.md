# Snapshot Array
[1146. Snapshot Array](https://leetcode.com/problems/snapshot-array/)

Implement a SnapshotArray that supports the following interface:

# Key insights
- Each index stores a history of (snap_id, value) pairs instead of copying the entire array on each snap
- Snap is O(1) -- just increments a counter rather than cloning data
- Get uses binary search on the history to find the most recent value at or before the given snap_id

# Code
```javascript
/**
 * @param {number} length
 */
var SnapshotArray = function(length) {
    // snap_id acts as our version number.
    this.snap_id = 0;
    
    // An array where each element will store the history of that index.
    this.data = new Array(length);
    // FIX: Initialize each index with its own unique history array.
    // Using .fill([[[0, 0]]]) would make all indices share the same array reference.
    for (let i = 0; i < length; i++) {
        // Each index starts with a history entry: [snap_id=0, value=0].
        // This handles the initial state and ensures our binary search always finds a value.
        this.data[i] = [[0, 0]];
    }
};

/** 
 * @param {number} index 
 * @param {number} val
 * @return {void}
 */
SnapshotArray.prototype.set = function(index, val) {
    const history = this.data[index];
    const lastSnap = history[history.length - 1][0];

    // If a value has already been set at this index since the last snap,
    // just update it. Otherwise, add a new history entry.
    if (lastSnap === this.snap_id) {
        history[history.length - 1][1] = val;
    } else {
        history.push([this.snap_id, val]);
    }
};

/**
 * @return {number}
 */
SnapshotArray.prototype.snap = function() {
    // Simply increment the snap_id. This is an O(1) operation.
    this.snap_id++;
    return this.snap_id - 1;
};

/** 
 * @param {number} index 
 * @param {number} snap_id
 * @return {number}
 */
SnapshotArray.prototype.get = function(index, snap_id) {
    const history = this.data[index];
    
    // Use binary search to find the value at the given snap_id.
    let left = 0;
    let right = history.length - 1;
    let result_idx = -1;
    
    while (left <= right) {
        let mid = Math.floor(left + (right - left) / 2);
        let [current_snap, ] = history[mid];
        
        if (current_snap <= snap_id) {
            // This is a valid historical value. Store it and
            // try to find a more recent one in the right half.
            result_idx = mid;
            left = mid + 1;
        } else {
            // This snapshot is too recent, search in the left half.
            right = mid - 1;
        }
    }
    
    return history[result_idx][1];
};
```

# Complexity
**Time:** O(1) for set and snap; O(log S) for get, where S is the number of sets on that index
**Space:** O(n + total sets) -- initial array plus all historical entries
