# Intersection of Two Arrays II
[350. Intersection of Two Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/)

Two pointers:

Hash Map:

# Key insights
* Sort both arrays first to enable ordered comparison
* Use two-pointer technique to traverse both sorted arrays simultaneously
* Advance pointers based on value comparison to find matching elements
* Preserves duplicate count by including all matching pairs

# Code
```javascript
var intersect = function(nums1, nums2) {
    nums1.sort((a, b) => a - b);
    nums2.sort((a, b) => a - b);
    const results = [];
    let i = 0;
    let j = 0;
    while (i < nums1.length && j < nums2.length) {
        if (nums1[i] == nums2[j]) {
            results.push(nums1[i]);
            i++;
            j++;
        } else if (nums1[i] < nums2[j]) {
            i++;
        } else {
            j++;
        }
    }
    return results;
};
```
```javascript
var intersect = function(nums1, nums2) {
    const map = new Map();
    for (const n of nums1) {
        map.set(n, (map.get(n) || 0) + 1);
    }
    
    const res = [];
    for (const n of nums2){
        if (map.get(n) > 0) {
            res.push(n);
            map.set(n, map.get(n) - 1);
        }
    }
    return res;
};
```

# Complexity
**Solution 1:**
**Time:** O(n log n + m log m) - sorting both arrays dominates the complexity, where n and m are the lengths of nums1 and nums2
**Space:** O(1) - only uses constant extra space for variables, not counting the output array

**Solution 2:**
**Time:** O(n + m) - iterates through each array once to build the map and find intersections
**Space:** O(min(n, m)) - uses a hash map to store counts of elements from the smaller array
