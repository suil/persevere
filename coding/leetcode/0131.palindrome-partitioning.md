# Palindrome Partitioning (Medium)
[131. Palindrome Partitioning (Medium)](https://leetcode.com/problems/palindrome-partitioning/description/)

Given a string s, partition s such that every 
substring
 of the partition is a 
palindrome
. Return all possible palindrome partitioning of s.

Example 1:

Input: s = "aab"
Output: [["a","a","b"],["aa","b"]]
Example 2:

Input: s = "a"
Output: [["a"]]

# Key insights
* Use backtracking to explore all possible partition combinations recursively
* Check palindrome with two pointers from start and end moving inward
* Generate substrings incrementally and only recurse on valid palindromes
* Base case: empty string means valid partition found, add to results

# Code
```javascript
var partition = function(s) {
    const output = [];
    partitionHelper(s, [], output);
    return output;
};
function partitionHelper(s, partitions, output) {
    if (s.length === 0) {
        output.push([...partitions]);
        return;
    }
    
    for (let i = 0; i < s.length; i++) {
        const substr = s.substring(0, i + 1);
        if (isPalindrome(substr)) {
            const nextS = s.substring(i + 1);
            const nextPartitions = [...partitions, substr];
            partitionHelper(nextS, nextPartitions, output);
        }
    }
}
function isPalindrome (s) {
    if (!s) {
        return false;
    }
    let start = 0;
    let end = s.length - 1;
    while (start < end) {
        if (s[start++] !== s[end--]) {
            return false;
        }
    }
    return true;
}
```

# Complexity
**Time:** O(N * 2^N) - For each position we can choose to cut or not cut (2^N possibilities), and checking palindrome takes O(N) time
**Space:** O(N * 2^N) - In worst case all substrings are palindromes, storing all possible partitions with recursion depth of N
