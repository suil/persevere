# The Skyline Problem
[218. The Skyline Problem](https://leetcode.com/problems/the-skyline-problem/)

A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.

# Key insights
* Create events for building starts (negative height) and ends (positive height), sort by x then height
* Negative heights for starts ensures they're processed before ends at the same x, and taller starts first
* Maintain a sorted list of active heights â€” the max active height is always at the end
* A skyline key point occurs whenever the current max height changes after processing an event

# Code
```javascript
/**
 * @param {number[][]} buildings
 * @return {number[][]}
 */
var getSkyline = function(buildings) {
  const events = [];
  for (const [l, r, h] of buildings) {
    events.push([l, -h]); // Start of a building
    events.push([r, h]);  // End of a building
  }

  // Sort events by x-coordinate, then by height
  events.sort((a, b) => {
    if (a[0] !== b[0]) {
      return a[0] - b[0];
    } else {
      return a[1] - b[1]; // Process start events before end events for the same x
    }
  });

  // Use a data structure that can efficiently add, remove, and get the max height.
  // A sorted list or a balanced BST is ideal. Here we simulate it with a sorted array.
  // A max-heap is also a common choice but requires a custom implementation for efficient removal.
  const activeHeights = [0]; // Sorted list of active heights, always contains 0.
  let prevMax = 0;
  const res = [];

  for (const [x, h] of events) {
    const height = Math.abs(h);
    if (h < 0) { // It's a start event
      // Add the height to our list, maintaining sorted order.
      // This is O(N) for an array, but O(log N) for a balanced BST.
      const index = sortedIndex(activeHeights, height);
      activeHeights.splice(index, 0, height);
    } else { // It's an end event
      // Remove the height from our list.
      // This is O(N) for an array, but O(log N) for a balanced BST.
      const index = activeHeights.indexOf(height);
      if (index !== -1) {
        activeHeights.splice(index, 1);
      }
    }

    // The current max height is the last element in the sorted list.
    const curMax = activeHeights[activeHeights.length - 1];
    
    // If the max height changes, we have a new key point in the skyline.
    if (curMax !== prevMax) {
      // Optimization: If the last point in the result has the same x, update its height.
      // This handles cases where multiple events happen at the same x-coordinate.
      if (res.length > 0 && res[res.length - 1][0] === x) {
          res[res.length - 1][1] = curMax;
      } else {
          res.push([x, curMax]);
      }
      prevMax = curMax;
    }
  }

  // Final merge pass to remove redundant horizontal points
  const mergedRes = [res[0]];
  for (let i = 1; i < res.length; i++) {
    if (mergedRes[mergedRes.length - 1][1] !== res[i][1]) {
        if (mergedRes[mergedRes.length - 1][0] === res[i][0]) {
            mergedRes[mergedRes.length - 1][1] = Math.max(mergedRes[mergedRes.length - 1][1], res[i][1]);
        } else {
            mergedRes.push(res[i]);
        }
    }
  }

  return mergedRes;
};

// Helper function to find insertion point for a sorted array (binary search).
function sortedIndex(array, value) {
    let low = 0, high = array.length;
    while (low < high) {
        let mid = (low + high) >>> 1;
        if (array[mid] < value) low = mid + 1;
        else high = mid;
    }
    return low;
}
```

# Complexity
**Time:** O(n^2) - Sorting events is O(n log n), but inserting/removing from the sorted array is O(n) per event, giving O(n^2) overall.**Space:** O(n) - For the events array and the active heights list.
