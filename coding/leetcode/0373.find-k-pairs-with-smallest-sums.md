# Find K Pairs with Smallest Sums
[373. Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/)

Quick Select:

Heap:

# Key insights
* Use min-heap to efficiently track and extract pairs with smallest sums
* Initialize heap with only first column pairs to avoid storing all O(mn) combinations
* Incrementally add next pairs only when current pair is extracted from heap
* Limit initial pairs to min(nums1.length, k) to optimize for small k values

# Code
```javascript
var kSmallestPairs = function(nums1, nums2, k) {
    const res = [];
    if (nums1.length === 0 || nums2.length === 0 || k === 0) { return res; }
    const queue = new FastPriorityQueue((a, b) => a.sum < b.sum)
    
    for (let i = 0; i < Math.min(nums1.length, k); i++) {
        queue.add({
            index1: i,
            index2: 0,
            sum: nums1[i] + nums2[0]
        });
    }

    while (k > 0 && queue.size > 0) {
        const num = queue.poll();
        res.push([
            nums1[num.index1],
            nums2[num.index2] 
        ]);
        if (num.index2 < nums2.length - 1) {
            queue.add({
                index1: num.index1,
                index2: num.index2 + 1,
                sum: nums1[num.index1] + nums2[num.index2 + 1]
            });
        }
        k--;
    }
    return res;
};
```
```javascript
var kSmallestPairs = function(nums1, nums2, k) {
    // init heap 'the smallest element first'
    const heap = new FastPriorityQueue((n1, n2) => n1 - n2);

    // keep k largest elements in the heap
    for (const num of nums) {
        heap.add(n);
        if (heap.size() > k) { heap.poll(); }
    }

    // output
    return heap.poll();
}
```