# Reorganize String
[767. Reorganize String](https://leetcode.com/problems/reorganize-string/)

Given a string s, rearrange the characters of s so that any two adjacent characters are not the same. Return any possible rearrangement of s or return "" if not possible.

Example 1:

Input: s = "aab"
Output: "aba"
Example 2:

Input: s = "aaab"
Output: ""

Constraints:

1 <= s.length <= 500
s consists of lowercase English letters.

# Key insights

- **Max-heap greedy**: always dequeue the 2 most frequent remaining characters and append them — consecutive characters are guaranteed to be different
- Each round: dequeue top 2 from the heap, append both to result, decrement their counts, and re-enqueue each with count > 0
- **Infeasibility detection**: if only 1 element remains in the heap but its count > 1, it would be forced to repeat adjacently — return `""`
- No explicit pre-check needed; the infeasibility naturally surfaces when one character dominates and has nowhere else to go

# Code
```javascript
var reorganizeString = function(s) {
    const map = new Map();
    for (const char of s) {
        map.set(char, (map.get(char) || 0) + 1);
    }

    const pq = new PriorityQueue((a, b) => b.count - a.count);

    for (const [char, count] of map) {
        pq.enqueue({char, count});
    }

    let res = '';
    while (!pq.isEmpty()) {
        const chunk = [];
        for (let i = 0; i < 2; i++) {
            if (!pq.isEmpty()) chunk.push(pq.dequeue());
        }

        if (chunk.length === 1 && chunk[0].count > 1) {
            return "";
        }
        
        for (const elem of chunk) {
            elem.count--;
            if (elem.count > 0) pq.enqueue(elem);
            res += elem.char;
        }
    }
    return res;
};
```
# Complexity

- **Time**: O(n log k) — each character is enqueued/dequeued O(n) times total, each heap op is O(log k); since k ≤ 26, log k is constant, so effectively O(n)
- **Space**: O(k) for the heap and frequency map, plus O(n) for the result string
