# Integer Break
[343. Integer Break](https://leetcode.com/problems/integer-break)

backtracking solution:

dynamic programming solution:
don't need to consider the case of breaking into more than two numbers. as long as we could find two numbers with max product values for themselves, we could guarantee it's the max product as a result.

# Key insights
* Uses backtracking to generate all possible integer partitions with 2+ parts
* Explores combinations by recursively choosing numbers from 1 to n-1
* Calculates product of each valid partition to find maximum
* Inefficient O(2^n) approach - better solved with math insights about factors of 3

# Code
```javascript
var integerBreak = function(n) {
    const nums = [...Array(n)].map((_, index) => index + 1);
    const output = [];
    backtrack(nums, n, [], output);
  
    let maxProduct = 1;
    for (const com of output) {
        const product = com.reduce((p, n) => p * n, 1);
        maxProduct = Math.max(maxProduct, product);
    }
    return maxProduct;
};

function backtrack(nums, target, combinations, output) {
    const comSum = combinations.reduce((sum, n) => sum + n, 0);
    if (nums.length === 0 || comSum >= target) {
        if (comSum === target && combinations.length >= 2) {
            output.push([...combinations]);
        }
        return;
    }

    for (let i = 0; i < nums.length; i++) {
        const nextNums = nums.slice(i);
        const nextCombinations = [...combinations, nums[i]];
        backtrack(nextNums, target, nextCombinations, output);
    }
}
```
```javascript
var integerBreak = function(n) {
    const dp = [...Array(n + 1)].fill(1);
    
    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= i - 1; j++) {
            dp[i] = Math.max(dp[i], dp[j] * (i - j), j * (i - j)); 
        }
    }
    return dp[n];
};
```

# Complexity
**Solution 1:**
**Time:** O(n!) - generates all possible combinations of numbers that sum to n through backtracking, creating exponential number of combinations
**Space:** O(n!) - stores all valid combinations in output array, plus O(n) recursion depth

**Solution 2:**
**Time:** O(nÂ²) - nested loops where outer runs n times and inner runs up to n times for each iteration
**Space:** O(n) - uses dp array of size n+1 to store maximum products
