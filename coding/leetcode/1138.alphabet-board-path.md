# Alphabet Board Path
[1138. Alphabet Board Path](https://leetcode.com/problems/alphabet-board-path/)

On an alphabet board, we start at position (0, 0), corresponding to character board[0][0].

Here, board = ["abcde", "fghij", "klmno", "pqrst", "uvwxy", "z"], as shown in the diagram below.



We may make the following moves:


	'U' moves our position up one row, if the position exists on the board;
	'D' moves our position down one row, if the position exists on the board;
	'L' moves our position left one column, if the position exists on the board;
	'R' moves our position right one column, if the position exists on the board;
	'!' adds the character board[r][c] at our current position (r, c) to the answer.


(Here, the only positions that exist on the board are positions with letters on them.)

Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.

 
Example 1:
Input: target = "leet"
Output: "DDR!UURRR!!DDD!"
Example 2:
Input: target = "code"
Output: "RR!DDRR!UUL!R!"

 
Constraints:


	1 <= target.length <= 100
	target consists only of English lowercase letters.

# Key insights
- Maps each character to its (row, col) position on the 5-column alphabet board using character code arithmetic
- Moves up/left before down/right to avoid stepping off the board when navigating to/from 'z' (which is alone on the last row)
- Builds the path by appending directional characters for each step between current and target positions

# Code
```javascript
/**
 * @param {string} target
 * @return {string}
 */
var alphabetBoardPath = function(target) {
    function getPos(char) {
        const code = char.charCodeAt(0) - 'a'.charCodeAt(0);
        return { row: Math.floor(code / 5), col: code % 5 };
    }

    let res = '';
    let currRow = 0;
    let currCol = 0;

    for (const char of target) {
        const { row, col } = getPos(char);

        while (currRow > row) { res += 'U'; currRow--; }
        while (currCol > col) { res += 'L'; currCol--; }
        while (currRow < row) { res += 'D'; currRow++; }
        while (currCol < col) { res += 'R'; currCol++; }
        res += '!';
    }
    return res;
};
```

# Complexity
**Time:** O(n * 10) = O(n) -- for each character in target, at most ~10 moves on a 6x5 board
**Space:** O(n) -- for the result string (proportional to total moves)
