# Largest Divisible Subset
[368. Largest Divisible Subset](https://leetcode.com/problems/largest-divisible-subset/)

Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:

# Key insights
- Sort the array first - if a < b and b % a == 0, any number divisible by b is also divisible by a
- DP similar to longest increasing subsequence: dp[i] = size of largest subset ending at nums[i]
- For each i, check all j < i where nums[i] % nums[j] == 0
- Use parent array to reconstruct the actual subset

# Code
```javascript
/**
 * LeetCode 368: Largest Divisible Subset
 *
 * Given a set of distinct positive integers nums, find the largest subset
 * such that every pair (Si, Sj) of elements in this subset satisfies:
 * Si % Sj == 0 or Sj % Si == 0.
 *
 * Approach:
 * - Sort nums ascending.
 * - DP[i] = length of largest divisible subset ending at i.
 * - parent[i] = previous index in the subset chain for reconstruction.
 * - For each i, check all j < i. If nums[i] % nums[j] == 0 and dp[j] + 1 > dp[i],
 *   update dp[i] and parent[i].
 * - Track the maximum dp value and reconstruct the subset by following parents.
 *
 * Time: O(n^2), Space: O(n)
 *
 * @param {number[]} nums
 * @return {number[]}
 */
var largestDivisibleSubset = function(nums) {
    if (nums.length === 0) return [];
    nums.sort((a, b) => a - b);

    const n = nums.length;
    const dp = new Array(n).fill(1);
    const parent = new Array(n).fill(-1);

    let maxLen = 1;
    let maxIdx = 0;

    for (let i = 1; i < n; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[i] % nums[j] === 0 && dp[j] + 1 > dp[i]) {
                dp[i] = dp[j] + 1;
                parent[i] = j;
            }
        }
        if (dp[i] > maxLen) {
            maxLen = dp[i];
            maxIdx = i;
        }
    }

    // Reconstruct the subset
    const res = [];
    let k = maxIdx;
    while (k !== -1) {
        res.push(nums[k]);
        k = parent[k];
    }

    res.reverse();
    return res;
};

```

# Complexity
**Time:** O(n^2) - nested loops comparing all pairs
**Space:** O(n) - for dp and parent arrays
