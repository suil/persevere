# Rotating the Box
[1861. Rotating the Box](https://leetcode.com/problems/rotating-the-box/)

You are given an m x n matrix of characters boxGrid representing a side-view of a box. Each cell of the box is one of the following:

# Key insights
- Two-step process: apply gravity first, then rotate 90 degrees clockwise
- Gravity: scan each row right-to-left, track write position for stones
- Obstacles reset the write position; stones swap to write position and decrement it
- Rotation formula: rotated[col][rowLen-1-row] = original[row][col]

# Code
```javascript
/**
 * @param {character[][]} boxGrid
 * @return {character[][]}
 */
var rotateTheBox = function(boxGrid) {
    const rowLen = boxGrid.length;
    const colLen = boxGrid[0].length;

    // Gravity step: for each row separately, move stones '#' to the right as far as possible, blocked by obstacles '*'
    for (let row = 0; row < rowLen; row++) {
        let write = colLen - 1; // rightmost position to drop a stone
        for (let col = colLen - 1; col >= 0; col--) {
            if (boxGrid[row][col] === '*') {
                write = col - 1; // next stones can't go past this obstacle
            } else if (boxGrid[row][col] === '#') {
                if (col !== write) {
                    boxGrid[row][col] = '.';
                    boxGrid[row][write] = '#';
                }
                write--;
            }
            // if '.', do nothing
        }
    }

    // Rotate: create n x m output and fill w/ rotated values
    const rotatedGrid = Array(colLen).fill(0).map(() => Array(rowLen));
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            rotatedGrid[col][rowLen - 1 - row] = boxGrid[row][col];
        }
    }

    return rotatedGrid
};
/*
["#",".","*","."],
["#","#","*","."]

(0,0), (0,1), (0,2)
(1,0)

(0,0), (0,1)

*/
```

# Complexity
**Time:** O(m * n) - process each cell for gravity and rotation
**Space:** O(m * n) - for the rotated output grid
