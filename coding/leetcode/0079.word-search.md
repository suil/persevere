# Word Search
[79. Word Search](https://leetcode.com/problems/word-search/)

Given an m x n grid of characters board and a string word, return true if word exists in the grid.

# Key insights
- DFS/backtracking from every cell, matching one character at a time with `word.substring(1)`
- Use a visited matrix to prevent revisiting cells in the current path; unmark on backtrack
- Early termination: return false if out of bounds, already visited, or character mismatch

# Code
```javascript
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
    function dfs(word, startRow, startCol, visisted) {
        if (word.length === 0) return true;

        const char = word[0];
        if (board[startRow]?.[startCol] === undefined
            || visited[startRow][startCol] === true
            || char !== board[startRow][startCol]
        ) {
            return false;
        }

        visited[startRow][startCol] = true;

        const nextWord = word.substring(1);
        
        const hasFound = (
            dfs(nextWord, startRow + 1, startCol, visited)
            || dfs(nextWord, startRow - 1, startCol, visited)
            || dfs(nextWord, startRow, startCol + 1, visited)
            || dfs(nextWord, startRow, startCol - 1, visited)
        );

        visited[startRow][startCol] = false;
        return hasFound;
    }

    const rowLen = board.length;
    const colLen = board[0].length;
    const visited = Array(rowLen).fill().map(() => Array(colLen).fill(false));
    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (dfs(word, row, col, visited) === true) return true;
        }
    }
    return false;
};
```

# Complexity
**Time:** O(m * n * 4^L) where L is the word length
**Space:** O(m * n) for the visited matrix plus O(L) recursion depth
