# Last Stone Weight II
[1049. Last Stone Weight II](https://leetcode.com/problems/last-stone-weight-ii/)

You are given an array of integers stones where stones[i] is the weight of the ith stone.

# Key insights
- Reduces to a subset-sum problem: partition stones into two groups to minimize the absolute difference of their sums
- Uses 1D boolean DP where dp[i] indicates whether a subset sum of i is achievable
- Iterates backward from target (sum/2) to avoid using the same stone twice, then finds the largest achievable sum <= target

# Code
```javascript
/**
 * @param {number[]} stones
 * @return {number}
 */
var lastStoneWeightII = function(stones) {
    const sum = stones.reduce((s, n) => s + n, 0);
    const target = Math.floor(sum / 2);

    // function backtrack(index, total) {
    //     if (total >= target || index === stones.length) {
    //         return Math.abs(total - (sum - total));
    //     }

    //     return Math.min(
    //         backtrack(index + 1, total),
    //         backtrack(index + 1, total + stones[index])
    //     );
    // }

    // return backtrack(0, 0);

    const dp = Array(stones.length + 1).fill(false);
    dp[0] = true;

    for (let stone of stones) {
        for (let i = target; i >= stone; i--) {
            dp[i] = dp[i] || dp[i - stone];
        }
    }

    for (let j = target; j >= 0; j--) {
        if (dp[j] === true) {
            return Math.abs(j - (sum - j));
        }
    }

    return 0;
};
```

# Complexity
**Time:** O(n * S) -- where n is the number of stones and S is sum/2
**Space:** O(S) -- for the 1D DP array
