# Robot Room Cleaner
[489. Robot Room Cleaner](https://leetcode.com/problems/robot-room-cleaner/)

You are controlling a robot that is located somewhere in a room. The room is modeled as an m x n binary grid where 0 represents a wall and 1 represents an empty slot.

# Key insights
- Use DFS backtracking with a visited set to explore all reachable cells; track position via relative coordinates since the actual grid is unknown
- At each cell, try all 4 directions by turning right after each attempt, maintaining a consistent direction state
- The goBack helper reverses the robot's last move (turn 180, move, turn 180) to restore its position and orientation for backtracking

# Code
```javascript
/**
 * // This is the robot's control interface.
 * // You should not implement it, or speculate about its implementation
 * function Robot() {
 *     // Returns true if the cell in front is open and robot moves into the cell.
 *     // Returns false if the cell in front is blocked and robot stays in the current cell.
 *     @return {boolean}
 *     this.move = function() {
 *         ...
 *     };
 *
 *     // Robot will stay in the same cell after calling turnLeft/turnRight.
 *     // Each turn will be 90 degrees.
 *     @return {void}
 *     this.turnLeft = function() {
 *         ...
 *     };
 * 
 *     // Robot will stay in the same cell after calling turnLeft/turnRight.
 *     // Each turn will be 90 degrees.
 *     @return {void} 
 *     this.turnRight = function() {
 *         ...
 *     };
 *
 *     // Clean the current cell.
 *     @return {void}
 *     this.clean = function() {
 *         ...
 *     };
 * };
 */

/**
 * @param {Robot} robot
 * @return {void}
 */
var cleanRoom = function(robot) {
    const visited = new Set();
    // Directions: 0: up, 1: right, 2: down, 3: left
    const directions = [
        [-1, 0], // up
        [0, 1], // right
        [1, 0], // down
        [0, -1], // left
    ];

    function goBack() {
        robot.turnLeft();
        robot.turnLeft();
        robot.move();
        robot.turnLeft();
        robot.turnLeft();
    }

    function backtrack(row, col, direction) {
        const key = `${row}-${col}`;
        if (visited.has(key)) return;

        visited.add(key);
        robot.clean();

        for (let i = 0; i < 4; i++) {
            const nextDirection = (direction + i) % 4;
            const [dRow, dCol] = directions[nextDirection];
            const newRow = row + dRow;
            const newCol = col + dCol;

            if (robot.move()) {
                backtrack(newRow, newCol, nextDirection);
                goBack();
            }
            robot.turnRight();
        }
    }

    backtrack(0, 0, 0);
};
```

# Complexity
**Time:** O(N - M) where N is total cells and M is obstacle cells -- each open cell is visited once
**Space:** O(N - M) -- for the visited set and recursion stack
