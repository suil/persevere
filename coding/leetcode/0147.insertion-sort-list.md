# Insertion Sort List
[147. Insertion Sort List](https://leetcode.com/problems/insertion-sort-list/)

Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head.

The steps of the insertion sort algorithm:

Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.
At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.
It repeats until no input elements remain.
The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.

Example 1:
Input: head = [4,2,1,3]
Output: [1,2,3,4]

Example 2:
Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]

# Key insights
* Use dummy head node to simplify edge cases and insertion logic
* Classic insertion sort: find correct position for each node in sorted portion
* Save next pointer before insertion to avoid losing unsorted list continuation
* O(n²) time complexity due to nested traversal for each insertion

# Code
```javascript
var insertionSortList = function(head) {
    const fakeHead = new ListNode();
    let curr = head;
    
    while (curr !== null) {
        let prev = fakeHead;
        let next = fakeHead.next;
        
        while (next !== null) {
            if (curr.val < next.val) { break; }
            prev = prev.next;
            next = next.next;
        }
        
        const temp = curr.next;
        prev.next = curr;
        curr.next = next;
        curr = temp;
    }
    return fakeHead.next;
};
```

# Complexity
**Time:** O(n²) - For each of the n nodes, we potentially traverse the entire sorted portion to find the correct insertion position
**Space:** O(1) - Only uses a constant amount of extra space with pointers (fakeHead, curr, prev, next, temp)
