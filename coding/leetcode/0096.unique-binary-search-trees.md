# Unique Binary Search Trees
[96. Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/)

Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.

# Key insights
- dp[i] = number of unique BSTs with i nodes, computed using the Catalan number recurrence
- For each root j in [1, i], the count is dp[j-1] * dp[i-j] (left subtree count * right subtree count)
- Bottom-up DP starting from dp[0]=1, dp[1]=1

# Code
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function(n) {
    
    // function backtrack(num, memo) {
    //     if (num in memo) return memo[num];
    //     if (num <= 1) return 1;
    //     let count = 0;
    //     for (let i = 1; i <= num; i++) {
    //         count += backtrack(i - 1, memo) * backtrack(num - i, memo);
    //     }
    //     memo[num] = count;
    //     return count;
    // }

    // return backtrack(n, {});

    if (n <= 1) return 1;
    const dp = new Array(n + 1).fill(0);
    dp[0] = 1;
    dp[1] = 1;
    
    for (let i = 2; i <= n; i++) {
        for (let j = 1; j <= i; j++) {
            dp[i] += dp[j - 1] * dp[i - j];
        }
    }
    return dp[n];
};
```

# Complexity
**Time:** O(n^2)
**Space:** O(n)
