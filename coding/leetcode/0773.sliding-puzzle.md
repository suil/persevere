# Sliding Puzzle
[773. Sliding Puzzle](https://leetcode.com/problems/sliding-puzzle/)

On an 2 x 3 board, there are five tiles labeled from 1 to 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.

# Key insights
- Model the puzzle as a graph where each node is a board state and edges are valid tile swaps with the empty space
- BFS guarantees the minimum number of moves to reach the target state
- Serialize board state as JSON string for efficient visited-set lookups

# Code
```javascript
/**
 * @param {number[][]} board
 * @return {number}
 */
var slidingPuzzle = function(board) {
    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
    const targetState = [[1, 2, 3], [4, 5, 0]];

    if (JSON.stringify(board) === JSON.stringify(targetState)) return 0;

    let zeroRow = 0, zeroCol = 0;
    for (let r = 0; r < board.length; r++) {
        for (let c = 0; c < board[0].length; c++) {
            if (board[r][c] === 0) {
                zeroRow = r;
                zeroCol = c;
            }
        }
    }

    const visited = new Set([JSON.stringify(board)]);
    const queue = [{ row: zeroRow, col: zeroCol, state: board, steps: 0 }];

    while (queue.length > 0) {
        const { state, steps, row, col } = queue.shift();

        for (const [dRow, dCol] of directions) {
            const nextRow = row + dRow;
            const nextCol = col + dCol;

            if (state[nextRow]?.[nextCol] === undefined) continue;

            const newState = structuredClone(state);
            [newState[row][col], newState[nextRow][nextCol]] =
                [newState[nextRow][nextCol], newState[row][col]];

            const key = JSON.stringify(newState);
            if (visited.has(key)) continue;

            if (key === JSON.stringify(targetState)) return steps + 1;

            visited.add(key);
            queue.push({ row: nextRow, col: nextCol, state: newState, steps: steps + 1 });
        }
    }

    return -1;
};
```

# Complexity
**Time:** O((m*n)! * m*n) for the total number of board permutations times the cost per state**Space:** O((m*n)!) for the visited set and queue
