# LFU Cache
[460. LFU Cache](https://leetcode.com/problems/lfu-cache/)

Design and implement a data structure for a Least Frequently Used (LFU) cache.

Implement the LFUCache class:
- `LFUCache(int capacity)` Initializes the object with the capacity of the data structure.
- `int get(int key)` Gets the value of the key if it exists in the cache, otherwise returns -1.
- `void put(int key, int value)` Updates the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. If there is a tie, the least recently used key is removed.

The functions get and put must each run in O(1) average time complexity.

# Key insights
* Use a hashmap for key-to-value+frequency lookup, and a hashmap of frequency-to-doubly-linked-list (or ordered set) for O(1) eviction
* Track the minimum frequency (`minFreq`) to know which frequency bucket to evict from
* On `get` or `put` (existing key): increment the key's frequency, move it to the new frequency bucket
* On `put` (new key at capacity): evict the least recently used key from the `minFreq` bucket, then insert with frequency 1
* Reset `minFreq` to 1 whenever a new key is inserted

# Code
```javascript
var LFUCache = function(capacity) {
    this.capacity = capacity;
    this.keyMap = new Map();       // key -> { value, freq }
    this.freqMap = new Map();      // freq -> Map (acts as ordered set, insertion order = LRU)
    this.minFreq = 0;
};

LFUCache.prototype.get = function(key) {
    if (!this.keyMap.has(key)) return -1;
    const entry = this.keyMap.get(key);
    this._updateFreq(key, entry);
    return entry.value;
};

LFUCache.prototype.put = function(key, value) {
    if (this.capacity === 0) return;

    if (this.keyMap.has(key)) {
        const entry = this.keyMap.get(key);
        entry.value = value;
        this._updateFreq(key, entry);
        return;
    }

    if (this.keyMap.size === this.capacity) {
        const bucket = this.freqMap.get(this.minFreq);
        const evictKey = bucket.keys().next().value;
        bucket.delete(evictKey);
        if (bucket.size === 0) this.freqMap.delete(this.minFreq);
        this.keyMap.delete(evictKey);
    }

    const entry = { value, freq: 1 };
    this.keyMap.set(key, entry);
    if (!this.freqMap.has(1)) this.freqMap.set(1, new Map());
    this.freqMap.get(1).set(key, true);
    this.minFreq = 1;
};

LFUCache.prototype._updateFreq = function(key, entry) {
    const oldFreq = entry.freq;
    const bucket = this.freqMap.get(oldFreq);
    bucket.delete(key);
    if (bucket.size === 0) {
        this.freqMap.delete(oldFreq);
        if (this.minFreq === oldFreq) this.minFreq++;
    }

    entry.freq++;
    if (!this.freqMap.has(entry.freq)) this.freqMap.set(entry.freq, new Map());
    this.freqMap.get(entry.freq).set(key, true);
};
```

# Complexity
**Time:** O(1) - Both get and put operations use hashmap lookups and insertions/deletions, all constant time.**Space:** O(n) - Where n is the capacity, storing entries in the key map and frequency buckets.
