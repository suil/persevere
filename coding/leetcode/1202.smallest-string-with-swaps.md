# Smallest String With Swaps
[1202. Smallest String With Swaps](https://leetcode.com/problems/smallest-string-with-swaps/)

Union Find:

DFS:

# Key insights
* Use Union-Find to group indices that can be swapped through transitive relationships
* Group connected components together to identify which positions can exchange characters
* Sort characters within each connected component to achieve lexicographically smallest arrangement
* Map sorted characters back to original positions within each component

# Code
```javascript
var smallestStringWithSwaps = function(s, pairs) {
    const n = s.length;

    const uf = new UnionFind(s.length);
    for (let [a, b] of pairs) {
        uf.union(a, b);
    }

    const groups = {}
    for (let i = 0; i < n; i++) {
        const root = uf.find(i);
        if (!groups[root]) { groups[root] = []; }
        groups[root].push(i)
    }

    let res = s.split('');
    for (const key in groups) {
        let group = groups[key];
        let sorted = [...group].sort((i1, i2) => s[i1].localeCompare(s[i2]))
        for (let i = 0; i < group.length; i++) {
            res[group[i]] = s[sorted[i]]
        }
    }
    return res.join('')
};
class UnionFind {
    constructor(n) {
        this.roots = [...Array(n)].map((_, index) => index);
    }
    
    find(key) {
        if (this.roots[key] === key) { return key; }
        
        this.roots[key] = this.find(this.roots[key]);
        return this.roots[key];
    }
    
    union(x, y) {
        const rootX = this.find(x);
        const rootY = this.find(y);
        
        if (rootX === rootY) { return false; }
        this.roots[rootX] = rootY;
        return true;
    }
}
```
```javascript
var smallestStringWithSwaps = function(s, pairs) {
    if (!pairs.length) { return s; }
    const graph = [...Array(s.length)].map(() => []);
    for (const [u, v] of pairs) {
        graph[u].push(v);
        graph[v].push(u);
    }

    let result = s.split('');
    let visited = new Array(s.length).fill(false);

    for (let i = 0; i < s.length; i++) {
        const indexes = [];
        dfs(s, graph, i, indexes, visited);
        indexes.sort((a, b) => a - b);
        const sorted = [...indexes].sort((a, b) => s[a].localeCompare(s[b]));
        for (let j = 0; j < indexes.length; j++) {
            result[indexes[j]] = s[sorted[j]];
        }
    }
    return result.join('');
};
function dfs(s, graph, current, indexes, visited) {
    if (visited[current]) { return; }
    visited[current] = true;
    indexes.push(current);
    for (const neighbor of graph[current]){
        dfs(s, graph, neighbor, indexes, visited);
    }
}
```