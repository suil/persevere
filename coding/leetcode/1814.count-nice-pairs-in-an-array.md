# Count Nice Pairs in an Array
[1814. Count Nice Pairs in an Array](https://leetcode.com/problems/count-nice-pairs-in-an-array/)

You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:

# Key insights
- Transform the nice pair condition: nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
- Rearrange to: nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])
- Count elements with same difference value using a hash map
- For each group of count c, number of pairs is c*(c-1)/2

# Code
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var countNicePairs = function(nums) {
    function reverse(num) {
        let res = 0;
        while (num !== 0) {
            res = res * 10 + num % 10;
            num = Math.floor(num / 10);
        }
        return res;
    }

    const mod = 1e9 + 7;
    const map = new Map();
    for (let i = 0; i < nums.length; i++) {
        const diff = nums[i] - reverse(nums[i]);
        map.set(diff, (map.get(diff) || 0) + 1);
    }

    let total = 0;
    for (const [num, count] of map) {
        total = (total + count * (count - 1) / 2) % mod;
    }

    return total;
};
/*
nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
nums[i] - nums[j] = rev(nums[i]) - rev(nums[j])
nums[i] - rev(nums[i]) = nums[j] - rev(nums[j])

42,11,1,97
1,11,42,97
1,11,24,79
*/
```

# Complexity
**Time:** O(n * d) - n elements, each reversed in O(d) where d is max digits
**Space:** O(n) - hash map storing difference counts
