# All O`one Data Structure
[432. All O`one Data Structure](https://leetcode.com/problems/all-oone-data-structure/)

Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.

# Key insights
- Doubly linked list where each node contains a count and a Set of keys with that count
- Nodes are ordered by count: head.next has minimum, tail.prev has maximum
- Map from key to its node enables O(1) lookup
- On inc/dec, move key to adjacent node (create if needed), remove empty nodes

# Code
```javascript
class Node {
    constructor(count) {
        this.count = count;
        this.keys = new Set();
        this.prev = null;
        this.next = null;
    }
}

var AllOne = function() {
    this.head = new Node(0); // dummy head
    this.tail = new Node(0); // dummy tail
    this.head.next = this.tail;
    this.tail.prev = this.head;
    this.keyToNode = new Map();
};

AllOne.prototype._addNodeAfter = (newNode, prevNode) => {
    newNode.next = prevNode.next;
    newNode.prev = prevNode;
    prevNode.next.prev = newNode;
    prevNode.next = newNode;
}

AllOne.prototype._removeNode = (node) => {
    node.prev.next = node.next;
    node.next.prev = node.prev;
}

/** 
 * @param {string} key
 * @return {void}
 */
AllOne.prototype.inc = function(key) {
    let node = this.keyToNode.get(key);
    let nextNode;

    if (!node) {
        node = this.head;
    }

    const newCount = node.count + 1;

    if (node.next.count !== newCount) {
        nextNode = new Node(newCount);
        this._addNodeAfter(nextNode, node);
    } else {
        nextNode = node.next;
    }

    nextNode.keys.add(key);
    this.keyToNode.set(key, nextNode);

    if (node !== this.head) {
        node.keys.delete(key);
        if (node.keys.size === 0) this._removeNode(node);
    }
};

/** 
 * @param {string} key
 * @return {void}
 */
AllOne.prototype.dec = function(key) {
    const node = this.keyToNode.get(key);
    if (!node) return;

    const newCount = node.count - 1;

    if (newCount === 0) {
        this.keyToNode.delete(key);
    } else {
        let prevNode;
        if (node.prev.count !== newCount) {
            prevNode = new Node(newCount);
            this._addNodeAfter(prevNode, node.prev);
        } else {
            prevNode = node.prev;
        }

        prevNode.keys.add(key);
        this.keyToNode.set(key, prevNode);
    }

    node.keys.delete(key);
    if (node.keys.size === 0) this._removeNode(node);
};

/**
 * @return {string}
 */
AllOne.prototype.getMaxKey = function() {
    return this.tail.prev === this.head ? "" : [...this.tail.prev.keys][0];
};

/**
 * @return {string}
 */
AllOne.prototype.getMinKey = function() {
    return this.head.next === this.tail ? "" : [...this.head.next.keys][0];
};

/** 
 * Your AllOne object will be instantiated and called as such:
 * var obj = new AllOne()
 * obj.inc(key)
 * obj.dec(key)
 * var param_3 = obj.getMaxKey()
 * var param_4 = obj.getMinKey()
 */
```

# Complexity
**Time:** O(1) for all operations (inc, dec, getMaxKey, getMinKey)
**Space:** O(n) - for storing keys and nodes
