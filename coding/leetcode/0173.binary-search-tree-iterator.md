# Binary Search Tree Iterator
[173. Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/)

Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

Callingnext()will return the next smallest number in the BST.

Note:next()andhasNext()should run in average O(1) time and uses O(h) memory, wherehis the height of the tree.

# Key insights
* Pre-compute in-order traversal and store in array for O(1) iterator operations
* In-order traversal of BST yields sorted sequence of values
* Trade space O(n) for time - cache all values upfront during initialization
* Use array shift() for FIFO behavior to return values in sorted order

# Code
```javascript
var BSTIterator = function(root) {
    this.cache = []
    const traverse = (node) => {
        if (node === null) { return; }
        if (node.left) traverse(node.left);
        this.cache.push(node.val);
        if (node.right) traverse(node.right);
    }
    traverse(root);
};
/**
 * @return {number}
 */
BSTIterator.prototype.next = function() {
    return this.cache.shift();
};

/**
 * @return {boolean}
 */
BSTIterator.prototype.hasNext = function() {
    return this.cache.length > 0;
};
```

# Complexity
**Time:** O(n) - Constructor performs complete inorder traversal of n nodes, while next() and hasNext() are O(1) amortized
**Space:** O(n) - Stores all node values in cache array plus O(h) recursion stack during initialization where h is tree height
