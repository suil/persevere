# Maximum Number of Events That Can Be Attended
[1353. Maximum Number of Events That Can Be Attended](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended)
You are given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi.

You can attend an event i at any day d where startDayi <= d <= endDayi. You can only attend one event at any time d.

Return the maximum number of events you can attend.

Example 1:

![alt text](https://assets.leetcode.com/uploads/2020/02/05/e1.png)

Input: events = [[1,2],[2,3],[3,4]]
Output: 3
Explanation: You can attend all the three events.
One way to attend them all is as shown.
Attend the first event on day 1.
Attend the second event on day 2.
Attend the third event on day 3.

Example 2:

Input: events= [[1,2],[2,3],[3,4],[1,2]]
Output: 4

# Key insights

- Greedy approach: attend events that end earliest to maximize flexibility for future events
- Use a min-heap (priority queue) to track available events by their end day
- Process days sequentially from the earliest event start to the latest event end
- On each day, add all events that start on that day to the heap
- Remove events from the heap that have already ended (end day < current day)
- Attend the event with the earliest end day (top of min-heap) if available
- Sort events by start day to efficiently add them to the heap as we progress through days
- Each event can only be attended once, so remove it from heap after attending

# Code
```javascript
var maxEvents = function(events) {
    events.sort((a, b) => a[0] - b[0]); // Sort by start time
    const heap = new PriorityQueue((a, b) => a - b);
    let res = 0;
    let i = 0;
    let day = 1;

    while (i < events.length || heap.size() > 0) {
        // Add events that start today
        while (i < events.length && events[i][0] === day) {
            heap.push(events[i][1]);
            i++;
        }

        // Remove expired events
        while (heap.size() > 0 && heap.front() < day) {
            heap.pop();
        }

        // Attend the event that ends earliest
        if (heap.size() > 0) {
            heap.pop();
            res++;
        }

        day++;
    }

    return res;
};
```

# Complexity
**Time:** O(n log n) where n is the number of events - O(n log n) for sorting events and O(n log n) for heap operations (each event is added and removed once)
**Space:** O(n) for the min-heap which can store up to n events at once