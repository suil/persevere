# Flatten a Multilevel Doubly Linked List
[430. Flatten a Multilevel Doubly Linked List](https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/)

You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional child pointer. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure as shown in the example below.

# Key insights
- When encountering a node with a child, recursively flatten the child list
- Insert the flattened child list between the current node and its next
- Update prev/next pointers to maintain doubly linked list structure
- Traverse to end of flattened child to reconnect with the original next node

# Code
```javascript
/**
 * // Definition for a _Node.
 * function _Node(val,prev,next,child) {
 *    this.val = val;
 *    this.prev = prev;
 *    this.next = next;
 *    this.child = child;
 * };
 */

/**
 * @param {_Node} head
 * @return {_Node}
 */
var flatten = function(head) {
    let currNode = head;

    while (currNode) {
        if (currNode.child) { 
            const currNodeNext = currNode.next;
            const flattenedChild = flatten(currNode.child);
            currNode.next = flattenedChild
            if (currNode.next) currNode.next.prev = currNode;
            currNode.child = null;
                        
            while (currNode.next) {
                currNode = currNode.next;
            }
            
            currNode.next = currNodeNext;
            if (currNode.next) {
                currNode.next.prev = currNode;
            }
        } 
        currNode = currNode.next;
    }
    
    return head;

};
```

# Complexity
**Time:** O(n) - each node is visited once
**Space:** O(d) - recursion stack where d is maximum nesting depth
