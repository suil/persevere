# Parse Lisp Expression
[736. Parse Lisp Expression](https://leetcode.com/problems/parse-lisp-expression/)

You are given a string expression representing a Lisp-like expression to return the integer value of.

# Key insights
- Recursive evaluator handles three expression types: numbers, variables (looked up in scope), and parenthesized expressions (add/mult/let)
- Custom tokenizer respects parenthesis nesting so sub-expressions are kept as single tokens
- Each scope is a Map copied from the parent, providing proper variable shadowing for nested let expressions

# Code
```javascript
/**
 * @param {string} expression
 * @return {number}
 */
var evaluate = function(expression) {
    function evaluateExpr(expr, scope) {
        if (expr[0] !== '(') {
            if (isNaN(expr)) return scope.get(expr); // variable
            return Number(expr); // number
        }

        const tokens = parse(expr.substring(1, expr.length - 1));
        const first = tokens[0];

        if (first === 'add') {
            return evaluateExpr(tokens[1], new Map(scope)) + evaluateExpr(tokens[2], new Map(scope));
        }

        if (first === 'mult') {
            return evaluateExpr(tokens[1], new Map(scope)) * evaluateExpr(tokens[2], new Map(scope));
        }

        // 'let'
        const newScope = new Map(scope);
        for (let i = 1; i < tokens.length - 1; i += 2) {
            if (i === tokens.length - 2) {
                return evaluateExpr(tokens[i], newScope);
            }
            const variable = tokens[i];
            const value = evaluateExpr(tokens[i + 1], newScope);
            newScope.set(variable, value);
        }

        return evaluateExpr(tokens[tokens.length - 1], newScope);
    }

    function parse(expr) {
        const res = [];
        let balance = 0;
        let token = "";

        for (let i = 0; i < expr.length; i++) {
            const ch = expr[i];
            if (ch === '(') balance++;
            if (ch === ')') balance--;
            if (ch === ' ' && balance === 0) {
                if (token.length > 0) {
                    res.push(token);
                    token = "";
                }
            } else {
                token += ch;
            }
        }
        if (token.length > 0) res.push(token);
        return res;
    }

    return evaluateExpr(expression, new Map());
};
```

# Complexity
**Time:** O(n^2) in the worst case where n is expression length (parsing and scope copying at each level)
**Space:** O(n^2) for nested scope copies and recursion stack
