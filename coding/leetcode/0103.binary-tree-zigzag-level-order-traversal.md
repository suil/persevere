# Binary Tree Zigzag Level Order 
[103. Binary Tree Zigzag Level Order](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)

Companies
Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).

Example 1:

Input: root = [3,9,20,null,null,15,7]
Output: [[3],[20,9],[15,7]]
Example 2:

Input: root = [1]
Output: [[1]]
Example 3:

Input: root = []
Output: []

Constraints:

The number of nodes in the tree is in the range [0, 2000].
-100 <= Node.val <= 100

# Key Insights

- **DFS with level tracking**: traverse the tree recursively while tracking the current level
- **Alternate insertion direction**: use level parity (even/odd) to determine insertion direction
  - Even levels (0, 2, 4...): `push()` to append at the end (left to right)
  - Odd levels (1, 3, 5...): `unshift()` to prepend at the beginning (right to left)
- Initialize arrays lazily: create a new array for each level when first visited
- Alternative approach: BFS with a queue and reverse odd levels, or use a deque

# Code
```javascript
var zigzagLevelOrder = function(root) {
    const res = [];
    function dfs(node, level) {
        if (!node) return;
        if (res[level] === undefined) res.push([]);

        if (level % 2 === 0) {
            res[level].push(node.val);
        } else {
            res[level].unshift(node.val);
        }
        dfs(node.left, level + 1);
        dfs(node.right, level + 1);
    }
    dfs(root, 0);

    return res;
};
```

# Complexity

- **Time**: O(n) where n is the number of nodes â€” each node is visited once. Note: `unshift()` operations on odd levels add overhead but don't change the overall O(n) complexity.
- **Space**: O(h) for the recursion stack where h is the tree height, plus O(n) for the result array