# Sliding Window Median
[480. Sliding Window Median](https://leetcode.com/problems/sliding-window-median/)

The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.

# Key insights
- Use two heaps (max-heap for lower half, min-heap for upper half) to efficiently track the median of the sliding window
- Lazy deletion via a delayed map avoids expensive heap removal; elements are pruned from heap tops when encountered
- Maintain logical sizes (smallSize, largeSize) separately from actual heap sizes to account for lazily deleted elements
- Rebalance after every add/remove to ensure the max-heap has at most one extra element

# Code
```javascript

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var medianSlidingWindow = function(nums, k) {
  const maxHeap = new PriorityQueue((a, b) => b - a); // lower half
  const minHeap = new PriorityQueue((a, b) => a - b); // upper half
  const delayed = new Map(); // lazy deletion
  let smallSize = 0, largeSize = 0;

  function prune(heap) {
    while (!heap.isEmpty()) {
      const val = heap.front();
      if (!delayed.has(val)) break;
      const count = delayed.get(val);
      if (count === 1) delayed.delete(val);
      else delayed.set(val, count - 1);
      heap.dequeue();
    }
  }

  function balance() {
    if (smallSize > largeSize + 1) {
      const top = maxHeap.dequeue();
      minHeap.enqueue(top);
      smallSize--; largeSize++;
      prune(maxHeap);
    } else if (smallSize < largeSize) {
      const top = minHeap.dequeue();
      maxHeap.enqueue(top);
      largeSize--; smallSize++;
      prune(minHeap);
    }
  }

  function add(num) {
    if (maxHeap.isEmpty() || num <= maxHeap.front()) {
      maxHeap.enqueue(num);
      smallSize++;
    } else {
      minHeap.enqueue(num);
      largeSize++;
    }
    balance();
  }

  function remove(num) {
    delayed.set(num, (delayed.get(num) || 0) + 1);
    if (!maxHeap.isEmpty() && num <= maxHeap.front()) {
      smallSize--;
      if (num === maxHeap.front()) prune(maxHeap);
    } else {
      largeSize--;
      if (!minHeap.isEmpty() && num === minHeap.front()) prune(minHeap);
    }
    balance();
  }

  const res = [];
  for (let i = 0; i < nums.length; i++) {
    add(nums[i]);
    if (i >= k) remove(nums[i - k]);
    if (i >= k - 1) {
      if (k % 2 === 1) res.push(maxHeap.front());
      else res.push((maxHeap.front() + minHeap.front()) / 2);
    }
  }

  return res;
};

```

# Complexity
**Time:** O(n log k) -- each add/remove involves heap operations of O(log k)
**Space:** O(n) -- heaps and the delayed deletion map
