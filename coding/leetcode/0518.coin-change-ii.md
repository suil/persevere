# Coin Change II
[518. Coin Change II](https://leetcode.com/problems/coin-change-ii/)

Memoization:

DP:

# Key insights
* Recursive approach explores two choices: use current coin or skip it
* For each coin, recursively solve subproblems with reduced amount or fewer coins
* Binary decision tree structure leads to exponential time complexity O(2^n)
* Missing memoization causes repeated subproblem calculations (inefficient)

# Code
```javascript
var change = function(amount, coins) {
    if (amount === 0) {
        return 1;
    }
    if (coins.length === 0 || amount < 0) {
        return 0;
    }
    const taken = change(amount - coins[0], coins);
    const notTaken = change(amount, coins.slice(1));
    return taken + notTaken;
};
```
```javascript
var change = function(amount, coins) {
    const dp = [...Array(amount + 1)].fill(0);
    dp[0] = 1;
    for (const coin of coins) {
        for (let i = coin; i <= amount; i++) {
            dp[i] = dp[i] + dp[i - coin];
        }
    }
    return dp[amount];
};
```

# Complexity
**Solution 1:**
**Time:** O(2^(amount + coins.length)) - each recursive call branches into two paths (take/not take) without memoization, leading to exponential growth
**Space:** O(amount + coins.length) - recursion stack depth is bounded by the sum of amount reductions and coin array slicing

**Solution 2:**
**Time:** O(amount * coins.length) - nested loops iterate through each coin and each amount value up to the target
**Space:** O(amount) - uses a single DP array of size amount + 1 to store intermediate results
