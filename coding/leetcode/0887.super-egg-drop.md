# Super Egg Drop
[887. Super Egg Drop](https://leetcode.com/problems/super-egg-drop/)

You are given k identical eggs and you have access to a building with n floors labeled from 1 to n.

# Key insights
- DP with memoization: state is (eggs, floors)
- For each floor, two outcomes: egg breaks (check floors below) or doesn't (check floors above)
- Binary search optimization: find floor where broken = not_broken curves intersect
- The answer is 1 + max(broken, not_broken) at the optimal floor

# Code
```javascript
/**
 * @param {number} k
 * @param {number} n
 * @return {number}
 */
var superEggDrop = function(k, n) {
    function backtrack(eggs, floors, memo = new Map()) {
        const key = `${eggs},${floors}`;
        if (memo.has(key)) return memo.get(key);
        if (floors === 0) return 0;
        if (eggs === 1) return floors; // if there is only one egg, the min tries will have to be num of floors

        let low = 1, high = floors;
        let res = floors;

        while (low <= high) {
            const mid = Math.floor((low + high) / 2);
            const broken = backtrack(eggs - 1, mid - 1, memo);
            const notBroken = backtrack(eggs, floors - mid, memo);

            if (broken > notBroken) {
                high = mid - 1;
                res = Math.min(res, broken + 1);
            } else {
                low = mid + 1;
                res = Math.min(res, notBroken + 1);
            }
        }

        memo.set(key, res);
        return res;
    };

    return backtrack(k, n);
};

```

# Complexity
**Time:** O(k * n * log n) - k eggs, n floors, binary search per state
**Space:** O(k * n) - for memoization
