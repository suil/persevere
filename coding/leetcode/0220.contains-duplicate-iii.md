# Contains Duplicate III
[220. Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/)

You are given an integer array nums and two integers indexDiff and valueDiff.

# Key insights
- Use bucket sort with bucket size of valueDiff + 1 so elements in the same bucket are guaranteed within valueDiff
- Also check adjacent buckets (bucketId - 1 and bucketId + 1) for elements within valueDiff
- Maintain a sliding window of indexDiff by removing the bucket of the element that falls out of range

# Code
```javascript
/**
 * @param {number[]} nums
 * @param {number} indexDiff
 * @param {number} valueDiff
 * @return {boolean}
 */
var containsNearbyAlmostDuplicate = function(nums, indexDiff, valueDiff) {
    if (valueDiff < 0) return false;

    const buckets = new Map();
    const size = valueDiff + 1;

    for (let i = 0; i < nums.length; i++) {
        const num = nums[i];
        const bucketId = Math.floor(num / size);

        if (buckets.has(bucketId)) return true;

        if (buckets.has(bucketId - 1) && Math.abs(num - buckets.get(bucketId - 1)) <= valueDiff)
            return true;

        if (buckets.has(bucketId + 1) && Math.abs(num - buckets.get(bucketId + 1)) <= valueDiff)
            return true;

        buckets.set(bucketId, num);

        if (i >= indexDiff) {
            const oldBucketId = Math.floor(nums[i - indexDiff] / size);
            buckets.delete(oldBucketId);
        }
    }

    return false;
};
```

# Complexity
**Time:** O(n)**Space:** O(min(n, indexDiff))
