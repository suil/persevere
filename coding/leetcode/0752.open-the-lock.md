# Open the Lock
[752. Open the Lock](https://leetcode.com/problems/open-the-lock/)

You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.

# Key insights
- Model the problem as a shortest path in an unweighted graph where each node is a 4-digit combination
- BFS from "0000" explores all states level by level, guaranteeing the minimum number of moves
- Each state has 8 neighbors (4 wheels x 2 directions), and deadends are skipped during neighbor generation

# Code
```javascript
/**
 * @param {string[]} deadends
 * @param {string} target
 * @return {number}
 */
var openLock = function(deadends, target) {
    const deadendSet = new Set(deadends);
    if (deadendSet.has("0000")) return -1;

    const queue = [{ slot: '0000', step: 0 }];
    const visited = new Set(['0000']);

    function getNextSlots(slot) {
        const res = [];
        for (let slotPos = 0; slotPos < 4; slotPos++) {
            const currDigit = slot.substring(slotPos, slotPos + 1);
            const nextDigit = String((Number(currDigit) + 1 + 10) % 10);
            const prevDigit = String((Number(currDigit) - 1 + 10) % 10);
            const nextSlot = slot.substring(0, slotPos) + nextDigit + slot.substring(slotPos + 1);
            const prevSlot = slot.substring(0, slotPos) + prevDigit + slot.substring(slotPos + 1);
            
            if (!deadendSet.has(nextSlot)) res.push(nextSlot);
            if (!deadendSet.has(prevSlot)) res.push(prevSlot);
        }
        return res;
    }


    while (queue.length > 0) {
        const curr = queue.shift();
        
        if (curr.slot === target) { return curr.step; }

        const nextSlots = getNextSlots(curr.slot);
        for (const nextSlot of nextSlots) {
            if (visited.has(nextSlot)) continue;

            visited.add(nextSlot);

            queue.push({
                slot: nextSlot,
                step: curr.step + 1
            });
        }
    }
    return -1;
};
```

# Complexity
**Time:** O(10^4) since there are at most 10,000 possible combinations
**Space:** O(10^4) for the visited set and queue
