# Regular Expression Matching
[10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/)

Backtracking

Dynamic Programming

# Key insights
* Handle '*' wildcard with two recursive branches: skip pattern or match character and continue
* Use dynamic programming to avoid recomputing overlapping subproblems
* First character matching check handles both exact match and '.' wildcard cases
* Pattern matching requires careful handling of '*' lookahead before processing current character

# Code
```javascript
var isMatch = function(s, p) {
    return isMatchDP(s, p);
    if (p.length === 0) {
        return s.length === 0;
    }

    const firstMatch = s.length > 0 && (s[0] === p[0] || p[0] === '.');
    if (p.length >= 2 && p[1] === '*') {
        return (
            isMatch(s, p.substring(2)) || (firstMatch && isMatch(s.substring(1), p))
        );
    }
    return firstMatch && isMatch(s.substring(1), p.substring(1));
};
```
```javascript
function isMatchDP(s, p) {
    let dp = [...Array(s.length + 1)].map(() => [...Array(p.length + 1)].fill(false));
    dp[0][0] = true;

    for (let i = 1; i < dp[0].length; i++){
        if (p[i - 1] === '*' && dp[0][i - 2] === true){
            dp[0][i] = true;
        }
    }

    for (let i = 1; i < dp.length; i++) {
        for (let j = 1; j < dp[0].length; j++) {
            if (s[i - 1] === p[j - 1] || p[j - 1] == '.') {
                dp[i][j] = dp[i - 1][j - 1];
            } else if (p[j - 1] === '*') {
                dp[i][j] = dp[i][j - 2];
                if (p[j - 2] == '.' || p[j - 2] == s[i - 1]){
                    dp[i][j] = dp[i - 1][j] || dp[i][j];
                }
            }
        }
    }
    
    return dp[s.length][p.length];
}
```

# Complexity
**Solution 1:**
**Time:** O(2^(m+n)) - recursive solution with overlapping subproblems creates exponential branching where each call may spawn two recursive calls
**Space:** O(m+n) - recursion stack depth is bounded by the length of both strings plus substring creation overhead

**Solution 2:**
**Time:** O(m*n) - fills a 2D DP table of size (m+1) x (n+1) where each cell is computed in constant time
**Space:** O(m*n) - stores a 2D DP table of dimensions (m+1) x (n+1) where m and n are lengths of strings s and p
