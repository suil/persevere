# Find Servers That Handled Most Number of Requests
[1606. Find Servers That Handled Most Number of Requests](https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/)

You have k servers numbered from 0 to k-1 that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but cannot handle more than one request at a time. The requests are assigned to servers according to a specific algorithm:

# Key insights
*

# Code
```javascript
/**
 * @param {number} k
 * @param {number[]} arrival
 * @param {number[]} load
 * @return {number[]}
 */
var busiestServers = function(k, arrival, load) {
    // A MinPriorityQueue is assumed to be available in the environment.
    const busyQueue = new PriorityQueue((a, b) => a.end - b.end);;
    const serverCount = new Array(k).fill(0);

    // Use two sorted arrays to keep track of available servers.
    // This allows for efficient searching using binary search.
    let availableServers = Array.from({ length: k }, (_, i) => i);

    for (let i = 0; i < arrival.length; i++) {
        const arrivalTime = arrival[i];
        
        // Free up servers that have completed their tasks.
        while (!busyQueue.isEmpty() && busyQueue.front().end <= arrivalTime) {
            const { server } = busyQueue.dequeue();
            // Add the server back to the available list, maintaining sorted order.
            // In a real-world scenario, a balanced BST would be O(log k).
            // With an array, this splice operation can be O(k), but we'll accept it for this structure.
            const index = sortedIndex(availableServers, server);
            availableServers.splice(index, 0, server);
        }

        if (availableServers.length === 0) {
            continue; // All servers are busy, drop the request.
        }

        let preferredServerIndex = i % k;
        
        // OPTIMIZATION: Use binary search to find the next available server.
        // Find the first available server with an ID >= preferredServerIndex.
        let serverIdxInAvailable = findFirstGreaterOrEqual(availableServers, preferredServerIndex);

        // If no such server is found, wrap around and take the first available one.
        if (serverIdxInAvailable === -1) {
            serverIdxInAvailable = 0;
        }
        
        // Get the server ID and remove it from the available list.
        const assignedServer = availableServers[serverIdxInAvailable];
        availableServers.splice(serverIdxInAvailable, 1);
        
        serverCount[assignedServer]++;
        busyQueue.enqueue({ server: assignedServer, end: arrivalTime + load[i] });
    }

    const maxCount = Math.max(...serverCount);
    const res = [];
    for (let i = 0; i < k; i++) {
        if (serverCount[i] === maxCount) {
            res.push(i);
        }
    }
    return res;
};

// Helper function to find the insertion point to keep an array sorted.
function sortedIndex(array, value) {
    let low = 0, high = array.length;
    while (low < high) {
        let mid = (low + high) >>> 1;
        if (array[mid] < value) low = mid + 1;
        else high = mid;
    }
    return low;
}

// Helper function to find the index of the first element >= target in a sorted array.
function findFirstGreaterOrEqual(arr, target) {
    let left = 0, right = arr.length - 1;
    let result = -1;
    while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        if (arr[mid] >= target) {
            result = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return result;
}
```

# Complexity
**Time:**
**Space:**
