# Longest Turbulent Subarray
[978. Longest Turbulent Subarray](https://leetcode.com/problems/longest-turbulent-subarray/)

Given an integer array arr, return the length of a maximum size turbulent subarray of arr.

# Key insights
- Sliding window approach: expand right pointer when the comparison direction alternates from the previous one
- Tracks the previous comparison direction ('>') or ('<') to detect when the turbulence pattern breaks
- Resets left pointer to right-1 when two consecutive comparisons go the same direction, or to right when equal elements are found

# Code
```javascript
/**
 * @param {number[]} arr
 * @return {number}
 */
var maxTurbulenceSize = function(arr) {
    let left = 0, right = 1;
    let max = 1;
    let prev = '';
    
    while (right < arr.length) {
        if (arr[right - 1] > arr[right] && prev != '>') {
            max = Math.max(max, right - left + 1);
            right++;
            prev = '>';
        } else if (arr[right - 1] < arr[right] && prev != '<') {
            max = Math.max(max, right - left + 1);
            right++;
            prev = '<';
        } else {
            if (arr[right - 1] === arr[right]) {
                right = right + 1;
            }
            left = right - 1;
            prev = ''
        }
    }
    return max;
};
```

# Complexity
**Time:** O(n) -- single pass with two pointers
**Space:** O(1) -- only tracking pointers and previous direction
