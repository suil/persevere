# Binary Tree Preorder Traversal
[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)

Recursive

Non-recursive

# Key insights
* Recursive divide-and-conquer approach following preorder pattern (root-left-right)
* Base case handles null nodes by returning empty array
* Spread operator combines current node value with recursive results
* Time O(n) space O(h) where h is tree height due to call stack

# Code
```javascript
var preorderTraversal = function(root) {
    return preorderTraversalHelper(root);
};
function preorderTraversalHelper(node) {
    if (node === null) {
        return [];
    }
    return [
        node.val,
        ...preorderTraversalHelper(root.left),
        ...preorderTraversalHelper(root.right)
    ]
}
```
```javascript
var preorderTraversal = function(root) {
    const res = [];
    const stack = [root];
    while (stack.length > 0) {
        const node = stack.pop();
        if (node === null) { continue; }
        res.push(node.val);
        stack.push(node.right);
        stack.push(node.left);
    }
    return res;
};
```

# Complexity
**Solution 1:**
**Time:** O(n) - visits each node exactly once despite the spread operator creating new arrays
**Space:** O(nÂ²) - creates new arrays at each recursive call due to spread operator, leading to quadratic space usage

**Solution 2:**
**Time:** O(n) - visits each node exactly once using iterative traversal
**Space:** O(h) - uses explicit stack that grows up to the height of the tree in worst case
