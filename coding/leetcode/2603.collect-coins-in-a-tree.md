# Collect Coins in a Tree
[2603. Collect Coins in a Tree](https://leetcode.com/problems/collect-coins-in-a-tree/)

There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given an integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given an array coins of size n where coins[i] can be either 0 or 1, indicating whether there is a coin at node i.

Starting from any node, you need to collect all the coins such that you can collect a coin at a node if you are within 2 edges of it. Return the minimum number of edges you need to traverse to collect all coins and come back to the starting node.

# Key insights
* First, prune all leaf nodes that have no coins — they are useless to visit
* Then, prune two more layers of leaves — since we can collect coins from 2 edges away, we don't need to reach coin leaves directly
* The remaining edges form the subtree we must fully traverse
* Answer is 2 * (number of remaining edges), since every edge must be traversed in both directions

# Code
```javascript
var collectTheCoins = function(coins, edges) {
    const n = coins.length;
    const adj = Array.from({ length: n }, () => new Set());
    const degree = new Array(n).fill(0);

    for (const [u, v] of edges) {
        adj[u].add(v);
        adj[v].add(u);
        degree[u]++;
        degree[v]++;
    }

    // Phase 1: Remove leaves with no coins
    let queue = [];
    for (let i = 0; i < n; i++) {
        if (degree[i] === 1 && coins[i] === 0) queue.push(i);
    }

    let removedEdges = 0;
    while (queue.length > 0) {
        const node = queue.shift();
        removedEdges++;
        for (const neighbor of adj[node]) {
            adj[neighbor].delete(node);
            degree[neighbor]--;
            if (degree[neighbor] === 1 && coins[neighbor] === 0) queue.push(neighbor);
        }
        adj[node].clear();
    }

    // Phase 2: Remove 2 layers of remaining leaves (coin leaves we can reach from 2 away)
    for (let round = 0; round < 2; round++) {
        queue = [];
        for (let i = 0; i < n; i++) {
            if (degree[i] === 1 && adj[i].size > 0) queue.push(i);
        }
        for (const node of queue) {
            removedEdges++;
            for (const neighbor of adj[node]) {
                adj[neighbor].delete(node);
                degree[neighbor]--;
            }
            adj[node].clear();
        }
    }

    return 2 * (edges.length - removedEdges);
};
```

# Complexity
**Time:** O(n) - Each node is processed at most once during pruning phases.
**Space:** O(n) - Adjacency sets, degree array, and queue use linear space.
