# Cheapest Flights Within K Stops
[787. Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/)

There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.

# Key insights
- Modified Dijkstra using a priority queue, with state expanded to include stop count alongside city and cost
- Track best cost per (city, stops) pair to prune suboptimal paths without discarding paths that use fewer stops
- The stop constraint means a cheaper path with more stops may be invalid, so standard Dijkstra relaxation is insufficient

# Code
```javascript
/**
 * @param {number} n
 * @param {number[][]} flights
 * @param {number} src
 * @param {number} dst
 * @param {number} k
 * @return {number}
 */
var findCheapestPrice = function(n, flights, src, dst, k) {
    if (src === dst) return 0;
    
    const graph = new Map();

    for (const [from, to, price] of flights) {
        if (!graph.has(from)) {
            graph.set(from, []);
        }
        graph.get(from).push([to, price]);
    }

    const bestMap = new Map();
    bestMap.set(`${src}-0`, 0);

    const pq = new PriorityQueue((a, b) => a.price - b.price);
    pq.enqueue({ curr: src, price: 0, stop: 0 })

    while (!pq.isEmpty()) {
        const { curr, price, stop } = pq.dequeue();
        if (dst === curr) {
            return price;
        }
        if (stop > k) continue;

        for (const [nei, neiPrice] of graph.get(curr) || []) {
            const newPrice = price + neiPrice;
            const key = `${nei}-${stop + 1}`;

            if (!bestMap.has(key) || newPrice < bestMap.get(key)) {
                bestMap.set(key, newPrice);
                pq.enqueue({ curr: nei, price: newPrice, stop: stop + 1 });
            }
        }
    }
    return -1;
};
```

# Complexity
**Time:** O(n * k * log(n * k)) where n is cities and k is max stops (priority queue operations)
**Space:** O(n * k) for the bestMap and priority queue
