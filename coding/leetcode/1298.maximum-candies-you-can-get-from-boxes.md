# Maximum Candies You Can Get from Boxes
[1298. Maximum Candies You Can Get from Boxes](https://leetcode.com/problems/maximum-candies-you-can-get-from-boxes/)

You have n boxes labeled from 0 to n - 1. You are given four arrays: status, candies, keys, and containedBoxes where:

# Key insights
- BFS simulation: processes boxes from a queue, skipping locked boxes without keys (they remain in ownedBoxes for later)
- When a box is opened, its contained boxes are added to the queue and its keys may unlock previously owned but locked boxes
- Re-queues a box when a newly found key matches an already-owned box, enabling it to be opened

# Code
```javascript
/**
 * @param {number[]} status
 * @param {number[]} candies
 * @param {number[][]} keys
 * @param {number[][]} containedBoxes
 * @param {number[]} initialBoxes
 * @return {number}
 */
var maxCandies = function(status, candies, keys, containedBoxes, initialBoxes) {
    const ownedKeys = new Set();
    const ownedBoxes = new Set(initialBoxes);
    const queue = [...initialBoxes];
    const visited = new Set();

    let totalCandies = 0;

    while (queue.length > 0) {
        const box = queue.shift();

        // If we already opened this box before, skip
        if (visited.has(box)) continue;

        // If it's locked and we don't have the key, skip for now (but keep in ownedBoxes)
        if (status[box] === 0 && !ownedKeys.has(box)) continue;

        // Mark as opened
        visited.add(box);

        // Collect candies
        totalCandies += candies[box];

        // Add contained boxes to ownedBoxes
        for (const newBox of containedBoxes[box]) {
            ownedBoxes.add(newBox);
            queue.push(newBox); // We try to process it now (may skip if locked)
        }

        // Add new keys
        for (const key of keys[box]) {
            if (!ownedKeys.has(key)) {
                ownedKeys.add(key);
                // If we already own the box for this key, re-queue it for processing
                if (ownedBoxes.has(key)) queue.push(key);
            }
        }
    }

    return totalCandies;
};
```

# Complexity
**Time:** O(n) -- each box is opened at most once due to the visited set
**Space:** O(n) -- for the queue, visited set, and owned sets
