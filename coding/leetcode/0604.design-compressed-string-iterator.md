# Design Compressed String Iterator
[604. Design Compressed String Iterator](https://leetcode.com/problems/design-compressed-string-iterator/)

Design and implement a data structure for a compressed string iterator. The given compressed string will be in the form of each letter followed by a positive integer representing the number of this letter existing in the original uncompressed string.

# Key insights
- Lazily parse the compressed string: only extract the next character and its count when the current count reaches 0
- Handle multi-digit counts by accumulating digits in a loop (count * 10 + digit)
- hasNext checks both remaining unparsed string and remaining count of the current character

# Code
```javascript
/**
 * @param {string} compressedString
 */
var StringIterator = function(compressedString) {
    this.s = compressedString;
    this.index = 0;
    this.char = '';
    this.count = 0;
};

/**
 * @return {character}
 */
StringIterator.prototype.next = function() {
    if (!this.hasNext()) {
        return ' ';
    }

    if (this.count === 0) {
        this.char = this.s[this.index++];
        while (this.index < this.s.length && !isNaN(parseInt(this.s[this.index]))) {
            this.count = this.count * 10 + parseInt(this.s[this.index]);
            this.index++;
        }
        if (this.count === 0) {
            this.count = 1; // If no number follows, the count is 1
        }
    }

    this.count--;
    return this.char;
};

/**
 * @return {boolean}
 */
StringIterator.prototype.hasNext = function() {
    return this.index < this.s.length || this.count > 0;
};

/** 
 * Your StringIterator object will be instantiated and called as such:
 * var obj = new StringIterator(compressedString)
 * var param_1 = obj.next()
 * var param_2 = obj.hasNext()
 */
```

# Complexity
**Time:** O(1) amortized per next/hasNext call -- parsing advances the index incrementally
**Space:** O(1) -- only stores the current character, count, and index
