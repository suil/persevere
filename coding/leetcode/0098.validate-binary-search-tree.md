# Validate Binary Search Tree
[98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)

In-order traversal:

DFS:

# Key insights
* Uses in-order traversal which visits BST nodes in ascending order
* Tracks previous node to compare with current node for BST property
* Single traversal with O(h) space complexity where h is tree height
* Early termination on first violation prevents unnecessary traversal

# Code
```javascript
var isValidBST = function(root) {
    let prev = null
    function inOrder(node) {
        if (node === null) {
            return true;
        }
        if (!inOrder(node.left)) { return false; }
        if (prev !== null && prev.val >= node.val) { return false; }
        prev = node;
        return inOrder(node.right);
    }
    return inOrder(root, null);
};
```
```javascript
var isValidBST = function(root) {
    return isValidBSTHelper(root, -Infinity, Infinity);
};
function isValidBSTHelper(node, min, max) {
    if (node === null) { return true; }
    if (node.val <= min || node.val >= max) { return false; }
    return isValidBSTHelper(node.left, min, node.val) && isValidBSTHelper(node.right, node.val, max)
}
```

# Complexity
**Solution 1:**
**Time:** O(n) - performs in-order traversal visiting each node exactly once
**Space:** O(h) - uses recursion stack space proportional to tree height, where h can be O(log n) for balanced trees or O(n) for skewed trees

**Solution 2:**
**Time:** O(n) - visits each node exactly once to validate BST property
**Space:** O(h) - uses recursion stack space proportional to tree height, where h can be O(log n) for balanced trees or O(n) for skewed trees
