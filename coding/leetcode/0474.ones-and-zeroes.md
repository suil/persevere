# Ones and Zeroes
[474. Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes)

Memoization:

DP:

# Key insights
* Recursive memoization approach modeling 0/1 knapsack with two constraints
* For each string: either include it (if feasible) or skip it, take maximum
* Count 0s and 1s in current string to check constraint feasibility
* Decision tree explores all valid combinations by reducing available budget

# Code
```javascript
function memoization(strs, numOf0, numOf1) {
    if (strs.length === 0) {
        return 0;
    }
    
    const countOf0s = strs[0].split('').reduce((c, s) => s === '0' ? c + 1 : c, 0);
    const countOf1s = strs[0].split('').reduce((c, s) => s === '1' ? c + 1 : c, 0);

    if (countOf0s > numOf0 || countOf1s > numOf1) {
        return memoization(strs.slice(1), numOf0, numOf1);
    }

    return Math.max(
        memoization(strs.slice(1), numOf0 - countOf0s, numOf1 - countOf1s) + 1,
        memoization(strs.slice(1), numOf0, numOf1),
    );
}
```
```javascript
var findMaxForm = function(strs, m, n) {
    const dp = [...Array(m + 1)].map(a => [...Array(n + 1)].fill(0));
    for (const str of strs) {
        const count0 = strs[0].split('').reduce((c, s) => s === '0' ? c + 1 : c, 0);
        const count1 = strs[0].split('').reduce((c, s) => s === '1' ? c + 1 : c, 0);

        for (let zero = m; zero >= count0; zero--) {
            for (let one = n; one >= count1; one--) {
                dp[zero][one] = Math.max(1 + dp[zero - count0][one - count1], dp[zero][one]);
            }
        }
    }
    return dp[m][n];
};

```

# Complexity
**Solution 1:**
**Time:** O(2^n * L) - exponential due to exploring all subset combinations without memoization, where n is number of strings and L is average string length for counting 0s and 1s
**Space:** O(n * L) - recursion stack depth of n calls, each creating string slices of average length L

**Solution 2:**
**Time:** O(n * m * n * L) - iterates through n strings, for each string loops through m*n DP table entries, plus L time to count 0s and 1s per string
**Space:** O(m * n) - 2D DP table of size (m+1) x (n+1)
