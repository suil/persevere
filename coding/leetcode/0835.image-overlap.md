# Image Overlap
[835. Image Overlap](https://leetcode.com/problems/image-overlap/)

You are given two images, img1 and img2, represented as binary, square matrices of size n x n. A binary matrix has only 0s and 1s as values.

# Key insights
- Try all possible translations (row and column offsets) of one image over the other
- For each offset, count the number of positions where both images have a 1
- The offset ranges from -(n-1) to (n-1) in both dimensions, covering all possible shifts

# Code
```javascript
/**
 * @param {number[][]} img1
 * @param {number[][]} img2
 * @return {number}
 */
var largestOverlap = function(img1, img2) {
    let n = img1.length;
    let maxOverlap = 0;
    for (let row = -n + 1; row < n; row++) {
        for (let col = -n + 1; col < n; col++) {
            maxOverlap = Math.max(maxOverlap, overlapOnes(img1, img2, row, col));
        }
    }
    
    return maxOverlap;
//     let maxOverlaps = 0;

//     for (let yShift = 0; yShift < img1.length; ++yShift)
//         for (let xShift = 0; xShift < img1.length; ++xShift) {
//             // move the matrix A to the up-right and up-left directions.
//             maxOverlaps = Math.max(maxOverlaps, shiftAndCount(xShift, yShift, img1, img2));
//             // move the matrix B to the up-right and up-left directions, 
//             // which is equivalent to moving A to the down-right and down-left directions
//             maxOverlaps = Math.max(maxOverlaps, shiftAndCount(xShift, yShift, img2, img1));
//         }

//     return maxOverlaps;
};

// function shiftAndCount(xShift, yShift, M, R) {
//     let leftShiftCount = 0, rightShiftCount = 0;
//     let rRow = 0;
//     // count the cells of ones in the overlapping zone.
//     for (let mRow = yShift; mRow < M.length; ++mRow) {
//         let rCol = 0;
//         for (let mCol = xShift; mCol < M.length; ++mCol) {
//             if (M[mRow][mCol] == 1 && M[mRow][mCol] == R[rRow][rCol]) {
//                 leftShiftCount += 1;
//             }
//             if (M[mRow][rCol] == 1 && M[mRow][rCol] == R[rRow][mCol]) {
//                 rightShiftCount += 1;
//             }
//             rCol += 1;
//         }
//         rRow += 1;
//     }
//     return Math.max(leftShiftCount, rightShiftCount);
// }

function overlapOnes(img1, img2, rowOff, colOff) {
    let count = 0;
    for (let row = 0; row < img1.length; row++) {
        for (let col = 0; col < img1[0].length; col++) {
            if (img1[row + rowOff] === undefined || img1[row + rowOff][col + colOff] === undefined) {
                continue;
            }
            
            if (img1[row][col] + img2[row + rowOff][col + colOff] === 2) {
                count++;
            }
        }
    }
    return count;
}
```

# Complexity
**Time:** O(n^4) -- n^2 possible offsets, each requiring an n^2 overlap count**Space:** O(1)
