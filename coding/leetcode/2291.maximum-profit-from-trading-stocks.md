# Maximum Profit From Trading Stocks
[2291. Maximum Profit From Trading Stocks](https://leetcode.com/problems/maximum-profit-from-trading-stocks/)

You are given two 0-indexed integer arrays of the same length present and future where present[i] is the current price of the ith stock and future[i] is the price of the ith stock a year in the future. You may buy each stock at most once. You are also given an integer budget representing the amount of money you currently have.

Return the maximum amount of profit you can make.

# Key insights
* This is a 0/1 knapsack problem â€” each stock is an item with cost `present[i]` and profit `future[i] - present[i]`
* Only consider stocks where `future[i] > present[i]` (positive profit)
* Use a 1D DP array where `dp[j]` = max profit achievable with budget `j`
* Iterate stocks and update the DP array in reverse (standard knapsack technique)

# Code
```javascript
var maximumProfit = function(present, future, budget) {
    const stocks = [];
    const len = present.length;
    for (let i = 0; i < len; i++) {
        stocks.push({ cost: present[i], profit: future[i] - present[i] });
    }
    
    function backtrack(index, currCost, memo = {}) {
        const memoKey = `${index}-${currCost}`;
        if (memoKey in memo) return memo[memoKey];

        if (index >= len) { // more constrain
            memo[memoKey] = 0;
            return 0;
        }

        // not pick it
        let notPickProfit = backtrack(index + 1, currCost, memo);

        // pick it
        let pickProfit = -Infinity;
        if (currCost + stocks[index].cost <= budget) {
            pickProfit = stocks[index].profit + backtrack(index + 1, currCost + stocks[index].cost, memo);
        }

        memo[memoKey] = Math.max(notPickProfit, pickProfit);
        return memo[memoKey];
    }

    return backtrack(0, 0);
};
```
```javascript
var maximumProfit = function(present, future, budget) {
    const dp = new Array(budget + 1).fill(0);

    for (let i = 0; i < present.length; i++) {
        const profit = future[i] - present[i];
        if (profit <= 0) continue;
        for (let j = budget; j >= present[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - present[i]] + profit);
        }
    }

    return dp[budget];
};
```

# Complexity
**Time:** O(n * budget) - For each stock, iterate through all possible budget values.**Space:** O(budget) - 1D DP array of size budget + 1.
