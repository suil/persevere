# Path Sum IV
[666. Path Sum IV](https://leetcode.com/problems/path-sum-iv/)

If the depth of a tree is smaller than 5, then this tree can be represented by an array of three-digit integers. You are given an ascending array nums consisting of three-digit integers representing a binary tree with a depth smaller than 5, where for each integer:

# Key insights
- Encode each node as depth-position key in a map from the 3-digit representation (hundreds = depth, tens = position, ones = value)
- Use DFS from root (1,1), computing left child at (depth+1, pos*2-1) and right child at (depth+1, pos*2)
- At leaf nodes (no children in the map), add the accumulated path sum to the total

# Code
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var pathSum = function(nums) {
    const map = new Map();
    for (const num of nums) {
        const depth = Math.floor(num / 100);
        const pos = Math.floor((num % 100) / 10);
        const val = num % 10;
        map.set(`${depth}-${pos}`, val);
    }

    function backtrack(depth, pos, currSum) {
        if (!map.has(`${depth}-${pos}`)) {
            return 0;
        }

        // visit node
        currSum += map.get(`${depth}-${pos}`);

        // check leaf
        const nextDepth = depth + 1;
        const leftPos = pos * 2 - 1;
        const rightPos = pos * 2;
        if (!map.has(`${nextDepth}-${leftPos}`) && !map.has(`${nextDepth}-${rightPos}`)) {
            return currSum;
        }

        // visit children
        return backtrack(nextDepth, leftPos, currSum) + backtrack(nextDepth, rightPos, currSum);
    }

    return backtrack(1, 1, 0);
};
/*
215
level 2
pos: 1

level 3
pos: 1 * 2 - 1, 1 * 2
*/
```

# Complexity
**Time:** O(n) where n is the number of nodes -- each node is visited once
**Space:** O(n) -- for the map and recursion stack
