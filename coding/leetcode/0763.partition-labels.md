# Partition Labels
[763. Partition Labels](https://leetcode.com/problems/partition-labels/)

You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string "ababcc" can be partitioned into ["abab", "cc"], but partitions such as ["aba", "bcc"] or ["ab", "ab", "cc"] are invalid.

# Key insights
- First pass records the last occurrence index of each character
- Second pass uses a greedy approach: extend the current partition's end to the farthest last-occurrence of any character seen so far
- When the current index equals maxPos, all characters in the current partition are fully contained, so cut here

# Code
```javascript
/**
 * @param {string} s
 * @return {number[]}
 */
var partitionLabels = function(s) {
    const map = new Map();
    for (let i = 0; i < s.length; i++) {
        map.set(s[i], i);
    }

    const res = [];
    let maxPos = 0;
    let lastPos = 0;
    for (let i = 0; i < s.length; i++) {
        maxPos = Math.max(maxPos, map.get(s[i]));

        if (maxPos === i) {
            res.push(i - lastPos + 1);
            lastPos = i + 1;
            maxPos = 0;
        }
    }
    return res;
};
```

# Complexity
**Time:** O(n) where n is the string length**Space:** O(1) since the map has at most 26 entries (lowercase letters)
