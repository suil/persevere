# Verifying an Alien Dictionary
[953. Verifying an Alien Dictionary](https://leetcode.com/problems/verifying-an-alien-dictionary/)

In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.

# Key insights
- Build a map from each character to its position in the alien alphabet
- Compare adjacent words using the alien order
- Words are sorted if each word is <= the next in alien lexicographic order
- Handle prefix case: "apple" should come after "app", not before

# Code
```javascript
/**
 * @param {string[]} words
 * @param {string} order
 * @return {boolean}
 */
var isAlienSorted = function(words, order) {
    // order = "ngxlkthsjuoqcpavbfdermiywz";
    const orderMap = new Map();
    for (let i = 0; i < order.length; i++) {
        orderMap.set(order[i], i);
    }
    
    // console.log(compare("kuvp","q", orderMap))
    // return
    for (let i = 1; i < words.length; i++) {
        if (compare(words[i - 1], words[i], orderMap) > 0) {
            return false;
        }
    }
    return true;
};

function compare(word1, word2, orderMap) {
    // if (word1.length > word2.length) { return 1; }
    // if (word1.length < word2.length) { return -1; }
    
    const k = Math.min(word1.length, word2.length);
    for (let i = 0; i < k; i++) {
        if (word1[i] !== word2[i]) {
            if (orderMap.get(word1[i]) > orderMap.get(word2[i])) {
                return 1;
            }
            if (orderMap.get(word1[i]) < orderMap.get(word2[i])) {
                return -1;
            }
            break;
        }
    }
    if (word1.length === word2.length) {
        return 0;
    }
    if (word1.length > word2.length) { return 1; }
    if (word1.length < word2.length) { return -1; }
}
/*
for (let j = 0; j < words.length - 1; j++) {
        let word1 = words[j];
        let word2 = words[j + 1];
        
        let minLen = Math.min(word1.length, word2.length);
        
        for (let k = 0; k < minLen; k++) {
            if (word1[k] !== word2[k]) {
                if (map.get(word1[k]) > map.get(word2[k])) {
                    return false;
                }
                break;
            }
        }
        
        if (word1.startsWith(word2) && word1.length > word2.length) {
            return false;
        }
    }
    
    return true;
    */
```

# Complexity
**Time:** O(n * m) - where n is number of words and m is max word length
**Space:** O(1) - order map has fixed 26 entries
