# Number of Ways to Stay in the Same Place After Some Steps
[1269. Number of Ways to Stay in the Same Place After Some Steps](https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/description/)

backtracking:

memoization:

dp:

# Key insights
* Recursive backtracking explores all possible paths (stay, left, right) at each step
* Base cases: return to position 0 after exactly 'steps' moves to count valid paths
* Brute force approach without memoization leads to exponential time complexity
* Early termination when position goes out of bounds or exceeds step limit

# Code
```javascript
var numWays = function(steps, arrLen) {
    const output = { count: 0 }
    backtrack(steps, arrLen, 0, 0, output);
    return output.count;
};

function backtrack(steps, arrLen, currentPos, stepTaken, output) {
    if (currentPos < 0 || currentPos >= arrLen || stepTaken > steps) {
        return;
    }

    if (currentPos === 0 && stepTaken === steps) {
        output.count++;
        return;
    }


    const right = backtrack(steps, arrLen, currentPos + 1, stepTaken + 1, output);
    const left = backtrack(steps, arrLen, currentPos - 1, stepTaken + 1, output);
    const stay = backtrack(steps, arrLen, currentPos, stepTaken + 1, output);
}
```
```javascript
function memoize(steps, arrLen, currentPos, memo) {
    const MODULO = 1000000007;
    const key = `${steps}-${currentPos}`;

if (memo.has(key)) {
        return memo.get(key);
    }

    if (currentPos < 0 || currentPos >= arrLen || steps < 0) {
        memo.set(key, 0);
        return 0;
    }

    if (steps === 0 && currentPos === 0) {
        memo.set(key, 1);
        return 1;
    }

    const right = memoize(steps - 1, arrLen, currentPos + 1, memo);
    const left = memoize(steps - 1, arrLen, currentPos - 1, memo);
    const stay = memoize(steps - 1, arrLen, currentPos, memo);
    const numOfWays = (right + left + stay) % MODULO;

    memo.set(key, numOfWays);
    return numOfWays;
}
```
```javascript
function dp(steps, arrLen) {
    const MODULO = 1000000007;
    
    const dp = [...Array(steps + 1)].map(_ => [...Array(arrLen)].fill(0));
    dp[0][0] = 1;

    for (let step = 1; step <= steps; step++) {
        for (let pos = 0; pos < arrLen; pos++) {
            dp[step][pos] = (dp[step - 1][pos] + (dp[step - 1][pos - 1] || 0) + (dp[step - 1][pos + 1] || 0)) % MODULO;
        }
    }
    return dp[steps][0];
}
```

# Complexity
**Solution 1:**
**Time:** O(3^steps) - explores all 3 possible moves at each step without memoization
**Space:** O(steps) - recursion stack depth is at most steps

**Solution 2:**
**Time:** O(steps * min(steps, arrLen)) - memoized recursion with at most steps * reachable positions
**Space:** O(steps * min(steps, arrLen)) - memoization table size plus recursion stack

**Solution 3:**
**Time:** O(steps * arrLen) - nested loops iterate through all step-position combinations
**Space:** O(steps * arrLen) - 2D DP table stores values for all states
