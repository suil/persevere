# Reorder Routes to Make All Paths Lead to the City Zero
[1466. Reorder Routes to Make All Paths Lead to the City Zero](https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/)

There are n cities numbered from 0 to n - 1 and n - 1 roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.

# Key insights
- Build an undirected graph but store original directed edges in a Set to check direction
- DFS from node 0: for each edge traversed outward from 0, if the original direction points away from 0 (i.e., exists in existingRoutes), it needs to be reversed
- The tree structure guarantees every node is visited exactly once from node 0

# Code
```javascript
/**
 * @param {number} n
 * @param {number[][]} connections
 * @return {number}
 */
var minReorder = function(n, connections) {
    const graph = new Map();

    const existingRoutes = new Set();
    for (const [u, v] of connections) {
        if (!graph.has(u)) graph.set(u, []);
        if (!graph.has(v)) graph.set(v, []);
        graph.get(u).push(v);
        graph.get(v).push(u);
        existingRoutes.add(`${u}-${v}`);
    }

    // console.log(existingRoutes)

    const visited = new Set();
    let count = 0;
    function dfs(curr) {
        visited.add(curr);

        for (const nei of graph.get(curr) || []) {
            if (visited.has(nei)) continue;
            // console.log(`${curr}-${nei}`)
            if (existingRoutes.has(`${curr}-${nei}`)) {
                count++
            }
            dfs(nei)
        }
    }

    dfs(0)

    return count;
};
```

# Complexity
**Time:**
**Space:**
