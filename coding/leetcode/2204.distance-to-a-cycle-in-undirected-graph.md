# Distance to a Cycle in Undirected Graph
[2204. Distance to a Cycle in Undirected Graph](https://leetcode.com/problems/distance-to-a-cycle-in-undirected-graph/)

You are given a positive integer n representing the number of nodes in a connected undirected graph containing exactly one cycle. The nodes are numbered from 0 to n - 1 (inclusive).

You are also given a 2D integer array edges, where edges[i] = [node1i, node2i] denotes that there is a bidirectional edge connecting node1i and node2i in the graph.

The distance between two nodes a and b is defined to be the minimum number of edges between a and b.

Return an integer array answer of size n, where answer[i] is the minimum distance between the ith node and any node in the cycle.

# Key insights
* Use topological sort (iterative leaf removal) to identify the cycle nodes — repeatedly remove nodes with degree 1
* All remaining nodes after pruning are part of the cycle and have distance 0
* BFS outward from all cycle nodes simultaneously to compute distances for non-cycle nodes

# Code
```javascript
var distanceToCycle = function(n, edges) {
    const adj = Array.from({ length: n }, () => []);
    const degree = new Array(n).fill(0);

    for (const [u, v] of edges) {
        adj[u].push(v);
        adj[v].push(u);
        degree[u]++;
        degree[v]++;
    }

    // Topological pruning — remove leaves iteratively
    const queue = [];
    for (let i = 0; i < n; i++) {
        if (degree[i] <= 1) queue.push(i);
    }

    const inCycle = new Array(n).fill(true);
    while (queue.length > 0) {
        const node = queue.shift();
        inCycle[node] = false;
        for (const neighbor of adj[node]) {
            degree[neighbor]--;
            if (degree[neighbor] === 1) queue.push(neighbor);
        }
    }

    // BFS from all cycle nodes
    const dist = new Array(n).fill(-1);
    const bfsQueue = [];
    for (let i = 0; i < n; i++) {
        if (inCycle[i]) {
            dist[i] = 0;
            bfsQueue.push(i);
        }
    }

    while (bfsQueue.length > 0) {
        const node = bfsQueue.shift();
        for (const neighbor of adj[node]) {
            if (dist[neighbor] === -1) {
                dist[neighbor] = dist[node] + 1;
                bfsQueue.push(neighbor);
            }
        }
    }

    return dist;
};
```

# Complexity
**Time:** O(n) - Topological pruning and BFS each visit every node and edge once.

**Space:** O(n) - Adjacency list, degree array, and distance array all use linear space.
