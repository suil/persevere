# Paint House
[256. Paint House](https://leetcode.com/problems/paint-house)

Memoization:

DP:

# Key insights
* Use memoized recursion to avoid recomputing subproblems with same house/color state
* Dynamic programming approach: each house decision depends on optimal future choices
* Constraint handling: adjacent houses cannot have same color by exploring other options
* Map-based memoization with composite key reduces time complexity from exponential to O(n)

# Code
```javascript
const RED = 0, BLUE = 1, GREEN = 2;
var minCost = function(costs) {
    return Math.min(
        memoize(costs, 0, RED, new Map()),
        memoize(costs, 0, BLUE, new Map()),
        memoize(costs, 0, GREEN, new Map())
    );
};

function memoize(costs, n, color, memo) {
    const memoKey = `${n}-${color}`;
    if (memo.has(memoKey)) {
        return memo.get(memoKey);
    }

    if (n >= costs.length) {
        return 0;
    }

    let totalCost = costs[n][color];
    if (color === RED) {
        totalCost += Math.min(memoize(costs, n + 1, BLUE, memo), memoize(costs, n + 1, GREEN, memo));
    } else if (color === BLUE) {
        totalCost += Math.min(memoize(costs, n + 1, RED, memo), memoize(costs, n + 1, GREEN, memo));
    } else if (color === GREEN) {
        totalCost += Math.min(memoize(costs, n + 1, RED, memo), memoize(costs, n + 1, BLUE, memo));
    }

    memo.set(memoKey, totalCost);
    return totalCost;
}
```
```javascript
var minCost = function(costs) {
    let n = costs.length;
    const dp = [...Array(n)].map(_ => [...Array(3)].fill(0));
    dp[0][0] = costs[0][0];
    dp[0][1] = costs[0][1];
    dp[0][2] = costs[0][2];
    for (let i = 1; i < n; i++) {
        dp[i][0] = costs[i][0] + Math.min(dp[i - 1][1], dp[i - 1][2]);
        dp[i][1] = costs[i][1] + Math.min(dp[i - 1][0], dp[i - 1][2]);
        dp[i][2] = costs[i][2] + Math.min(dp[i - 1][0], dp[i - 1][1]);
    }
    return Math.min(dp[n - 1][0], dp[n - 1][1], dp[n - 1][2]);
};
```

# Complexity
**Solution 1:**
**Time:** O(n) - Each of the n*3 possible states (house, color) is computed once due to memoization
**Space:** O(n) - Memoization map stores at most n*3 entries plus O(n) recursion stack depth

**Solution 2:**
**Time:** O(n) - Single loop through n houses with constant work per iteration
**Space:** O(n) - 2D DP table of size n*3 to store minimum costs for each house and color
