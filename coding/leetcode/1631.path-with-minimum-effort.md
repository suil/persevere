# Path With Minimum Effort
[1631. Path With Minimum Effort](https://leetcode.com/problems/path-with-minimum-effort/)

You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.

# Key insights
*

# Code
```javascript
/**
 * @param {number[][]} heights
 * @return {number}
 */
var minimumEffortPath = function(heights) {
    return minimumEffortPathRollingTableDP(heights)
  // var m = heights.length;
  // var n = heights[0].length;
  // var visited = new Set();
  // var l = 0;
  // var r = 1000000;
  // while (l < r) {
  //   var mid = Math.floor(l + (r - l) / 2);
  //   visited = new Set();
  //   if (dfs(heights, 0, 0, mid, visited)) {
  //     // can finish dfs
  //     r = mid;
  //   } else {
  //     l = mid + 1;
  //   }
  // }
  // return l;
};

function dfs(heights, row, col, mid, visited) {
    const dir = [
        [0, 1],
        [0, -1],
        [1, 0],
        [-1, 0]
    ];
    const code = `${row},${col}`;
    if (visited.has(code)) {
        return false;
    }
    if (row === heights.length - 1 && col === heights[0].length - 1) {
        return true;
    }

    visited.add(code);
    
    for (const [deltaRow, deltaCol] of dir) {
        const nextRow = row + deltaRow;
        const nextCol = col + deltaCol;
        
        if (heights[nextRow] === undefined || heights[nextRow][nextCol] === undefined) {
            continue;
        }
        
        var diff = Math.abs(heights[row][col] - heights[nextRow][nextCol]);
        if (diff > mid) continue;

        if (dfs(heights, nextRow, nextCol, mid, visited)) {
            return true;
        }
    }
    return false;
}

function minimumEffortPathRollingTableDP(heights) {
    const dp = [...Array(100)].map(_ => [...Array(100)].fill(Infinity));
    dp[0][0] = 0;
    const rowLen = heights.length;
    const colLen = heights[0].length;
    const directions = [
        [0, 1],
        [0, -1],
        [1, 0],
        [-1, 0]
    ];
    
    for (let k = 0; k < Math.max(rowLen, colLen); k++) {
        for (let row = 0; row < rowLen; row++) {
            for (let col = 0; col < colLen; col++) {
                for (let [deltaRow, deltaCol] of directions) {
                    const nextRow = row + deltaRow;
                    const nextCol = col + deltaCol;
                    if (heights[nextRow] === undefined || heights[nextRow][nextCol] === undefined) {
                        continue;
                    }
                    dp[row][col] = Math.min(
                        dp[row][col],
                        Math.max(dp[nextRow][nextCol], Math.abs(heights[row][col] - heights[nextRow][nextCol]))
                    );
                }
            }
        }
    }
    return dp[rowLen - 1][colLen - 1];
}
```

# Complexity
**Time:**
**Space:**
