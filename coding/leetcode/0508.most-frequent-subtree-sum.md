# Most Frequent Subtree Sum
[508. Most Frequent Subtree Sum](https://leetcode.com/problems/most-frequent-subtree-sum/)

Given the root of a binary tree, return the most frequent subtree sum. If there is a tie, return all the values with the highest frequency in any order.

The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself).

Example 1:
    5
   / \
  2   -3

Input: root = [5,2,-3]
Output: [2,-3,4]

Example 2:
    5
   / \
  2   -5
Input: root = [5,2,-5]
Output: [2]

# Key insights
* Use post-order DFS traversal to calculate subtree sums bottom-up
* HashMap tracks frequency of each subtree sum for O(1) counting
* Return subtree sum from recursive calls to build parent sums
* Filter results by maximum frequency to find most common sums

# Code
```javascript
var findFrequentTreeSum = function(root) {
    const sumFreq = new Map();
    findFrequentTreeSumHelper(root, sumFreq);
    
    const maxFreq = Math.max(...sumFreq.values());
    const res = [];
    for (const [num, freq] of sumFreq) {
        if (freq === maxFreq) { res.push(num); }
    }
    return res;
};
function findFrequentTreeSumHelper(node, sumFreq) {
    if (node === null) { return 0; }

    const left = findFrequentTreeSumHelper(node.left, sumFreq);
    const right = findFrequentTreeSumHelper(node.right, sumFreq);
    const sum = left + right + node.val;
    sumFreq.set(sum, (sumFreq.get(sum) || 0) + 1);
    return sum;
}
```

# Complexity
**Time:** O(n) - We visit each node exactly once to calculate subtree sums, then iterate through the map once to find maximum frequency and collect results.
**Space:** O(n) - In the worst case, we store n different subtree sums in the map, plus O(h) recursion stack space where h is the height of the tree.
