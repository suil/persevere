# Valid Parenthesis String
[678. Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string/)

Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.

# Key insights
- Memoized backtracking: track open and close counts, treating '*' as '(', ')', or empty
- Prune immediately when close > open (invalid prefix), and check open == close at the end
- Memoize on (index, open, close) to avoid exponential recomputation

# Code
```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var checkValidString = function(s) {
    function backtrack(currIndex, open, close, memo = {}) {
        const memoKey = `${currIndex}-${open}-${close}`;
        if (memoKey in memo) return memo[memoKey];

        if (close > open) {
            memo[memoKey] = false;
            return false;
        }

        if (currIndex === s.length) {
            memo[memoKey] = open === close;
            return open === close;
        }

        const currChar = s[currIndex];
    
        if (currChar === '(') {
            if (backtrack(currIndex + 1, open + 1, close, memo) === true) {
                memo[memoKey] = true;
                return true;
            }
        }

        if (currChar === ')') {
            if (backtrack(currIndex + 1, open, close + 1, memo) === true) {
                memo[memoKey] = true;
                return true;
            }
        }

        if (currChar === '*') {
            if (backtrack(currIndex + 1, open, close, memo) === true) {
                memo[memoKey] = true;
                return true;
            }
            if (backtrack(currIndex + 1, open + 1, close, memo) === true) {
                memo[memoKey] = true;
                return true;
            }
            if (backtrack(currIndex + 1, open, close + 1, memo) === true) {
                memo[memoKey] = true;
                return true;
            }
        }

        memo[memoKey] = false;
        return false;
    }

    return backtrack(0, 0, 0);
};
/*
(*))
 ^
*/
```

# Complexity
**Time:** O(n^3) -- at most n * n * n unique states (index, open, close)
**Space:** O(n^3) -- for the memoization table
