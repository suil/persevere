# Shortest Word Distance II
[244. Shortest Word Distance II](https://leetcode.com/problems/shortest-word-distance-ii/)

The core algorithm in this problem is to find min difference between values in two sorted arrays.
Example:

Array1: [1, 3, 10, 38]
Array2: [4, 9, 80, 100]

min distance = Math.abs(value1 from Array1 - value2 from Array2)

This can be solved by two pointers.

# Key insights
* Precompute word positions in hash map during initialization for efficient lookups
* Use two-pointer technique on sorted position arrays to find minimum distance
* Advance pointer with smaller position to explore all potential closer pairs
* Trade space for time: O(n) preprocessing enables O(m+k) query time per word pair

# Code
```javascript
var WordDistance = function(wordsDict) {
    this.map = new Map();
    for (let i = 0; i < wordsDict.length; i++) {
        const word = wordsDict[i];
        if (!this.map.has(word)) {
            this.map.set(word, []);
        }
        this.map.get(word).push(i);
    }
};

/** 
 * @param {string} word1 
 * @param {string} word2
 * @return {number}
 */
WordDistance.prototype.shortest = function(word1, word2) {
    const array1 = this.map.get(word1);
    const array2 = this.map.get(word2);
    let min = Infinity;

    let i1 = 0;
    let i2 = 0;

    while (i1 < array1.length && i2 < array2.length) {
        const position1 = array1[i1];
        const position2 = array2[i2];
        min = Math.min(min, Math.abs(position2 - position1));

        if (position1 < position2) {
            i1++;
        } else {
            i2++;
        }
    }
    return min;
};
```

# Complexity
**Constructor:**
**Time:** O(n) - iterates through all words in the input array once
**Space:** O(n) - stores all word positions in the map

**shortest method:**
**Time:** O(m + k) - uses two pointers to traverse arrays of word1 and word2 occurrences where m and k are the frequencies of each word
**Space:** O(1) - only uses constant extra space for variables
