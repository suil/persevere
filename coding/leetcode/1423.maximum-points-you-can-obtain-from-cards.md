# Maximum Points You Can Obtain from Cards
[1423. Maximum Points You Can Obtain from Cards](https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/)

There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints.

# Key insights
- Instead of choosing k cards from ends, finds the minimum-sum subarray of length (n - k) in the middle
- Uses a sliding window of size (n - k) to compute the minimum window sum, then subtracts from the total
- This converts an end-picking problem into a contiguous subarray problem

# Code
```javascript
/**
 * @param {number[]} cardPoints
 * @param {number} k
 * @return {number}
 */
var maxScore = function(cardPoints, k) {
    let winSum = 0;
    let total = 0;
    let res = 0;
    for (const cardPoint of cardPoints) total += cardPoint;
    const n = cardPoints.length;

    for(let i = 0; i < n - k; i++){
        winSum += cardPoints[i];
    }
    res = total - winSum;

    for(let i = n - k; i < n; i++){
        winSum += cardPoints[i] - cardPoints[i - (n - k)];
        res = Math.max(res, total - winSum);
    }

    return res;
};

function maxScoreHelper(cardPoints, start, last, k, memo) {
    if (k === 0) {
        return 0;
    }

    if (memo[start][last]) {
        return memo[start][last];
    }
    
    const firstItem = cardPoints[start];
    const lastItem = cardPoints[last];
    
    const takeFirstItemSum = firstItem + maxScoreHelper(cardPoints, start + 1, last, k - 1, memo);
    const takeLastItemSum = lastItem + maxScoreHelper(cardPoints, start, last - 1, k - 1, memo);
    
    const max = Math.max(takeFirstItemSum, takeLastItemSum);
    memo[start][last] = max;
    return max;
}
```

# Complexity
**Time:** O(n) -- single pass to compute total, then sliding window of size n-k
**Space:** O(1) -- only tracking sums and pointers
