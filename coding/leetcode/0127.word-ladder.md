# Word Ladder
[127. Word Ladder](https://leetcode.com/problems/word-ladder/)

Given two words beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.

Each transformed word must exist in the word list. Only one letter can be changed at a time.

# Key insights
* BFS gives the shortest path in an unweighted graph
* Each word is a node; edges connect words that differ by exactly one letter
* Use a set for the word list for O(1) lookup
* For each word, try changing each character to every letter a-z to find neighbors

# Code
```javascript
var ladderLength = function(beginWord, endWord, wordList) {
    function hasOneWordDiff(word1, word2) {
        if (word1.length !== word2.length) return false;
        let count = 0;
        for (let i = 0; i < word1.length; i++) {
            if (word1[i] != word2[i]) count++;
            if (count > 1) return false;
        }
        return true;
    }

    const queue = [{ word: beginWord, step: 1 }];
    const visited = new Set([beginWord]);

    while (queue.length > 0) {
        const curr = queue.shift();

        if (curr.word === endWord) { return curr.step }

        for (const nextWord of wordList) {
            if (visited.has(nextWord)) continue;
            if (hasOneWordDiff(nextWord, curr.word)) {
                visited.add(nextWord);
                queue.push({ word: nextWord, step: curr.step + 1 });
            }
        }
    }

    return 0;
};
```

# Complexity
**Time:** O(n * k * 26) - Where n is the number of words and k is the word length, trying 26 characters at each position.**Space:** O(n) - For the visited set and queue.
