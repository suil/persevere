# 3Sum With Multiplicity
[923. 3Sum With Multiplicity](https://leetcode.com/problems/3sum-with-multiplicity/)

Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i < j < k and arr[i] + arr[j] + arr[k] == target.

# Key insights
- Sort array and use two-pointer technique like classic 3Sum
- Count frequency of each element to handle multiplicities
- Use combinatorics: C(n,3) if all same, C(n,2)*m if two same, n*m*k if all different
- Skip duplicates in the main loop to avoid recounting

# Code
```javascript
/**
 * @param {number[]} arr
 * @param {number} target
 * @return {number}
 */
var threeSumMulti = function(arr, target) {
    const MOD = 1e9 + 7;
    arr.sort((a, b) => a - b);

    const map = new Map();
    for (const el of arr) {
        map.set(el, (map.get(el) || 0) + 1);
    }
    
    const res = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === arr[i - 1]) continue;

        let left = i + 1, right = arr.length - 1;
        while (left < right) {
            const sum = arr[i] + arr[left] + arr[right];
            if (sum > target) {
                right--;
            } else if (sum < target) {
                left++;
            } else {
                res.push([i, left, right]);
                while (left < right && arr[left] === arr[left + 1]) left++;
                while (left < right && arr[right] === arr[right - 1]) right--;
                right--;
                left++;
            }
        }
    }

    let count = 0;
    for (const [i1, i2, i3] of res) {
        if (arr[i1] === arr[i2] && arr[i1] === arr[i3]) {
            count += map.get(arr[i1]) * (map.get(arr[i1]) - 1) * (map.get(arr[i1]) - 2) / 6;
        } else if (arr[i1] === arr[i2] && arr[i2] !== arr[i3]) {
            count += (map.get(arr[i1]) * (map.get(arr[i1]) - 1) / 2) * map.get(arr[i3]);
        } else if (arr[i1] !== arr[i2] && arr[i2] === arr[i3]) {
            count += map.get(arr[i1]) * map.get(arr[i3]) * (map.get(arr[i3]) - 1) / 2;
        } else {
            count += map.get(arr[i1]) * map.get(arr[i2]) * map.get(arr[i3])
        }
        count %= MOD;
    }
    return count;
};
```

# Complexity
**Time:** O(n^2) - sorting + two-pointer scan for each unique first element
**Space:** O(n) - for the frequency map
