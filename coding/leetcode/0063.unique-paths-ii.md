# Unique Paths II
[63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)

You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

# Key insights
- DP where dp[row][col] = number of paths to reach (row, col), set to 0 if the cell is an obstacle
- Each cell's value is the sum of the cell above and the cell to the left (using optional chaining for boundary safety)
- Initialize dp[0][0] based on whether the start cell is free

# Code
```javascript
/**
 * @param {number[][]} obstacleGrid
 * @return {number}
 */
var uniquePathsWithObstacles = function(obstacleGrid) {
    const rowLen = obstacleGrid.length;
    const colLen = obstacleGrid[0].length;
    const dp = Array(rowLen).fill().map(() => Array(colLen).fill(0));
    dp[0][0] = obstacleGrid[0][0] === 0 ? 1 : 0;

    for (let row = 0; row < rowLen; row++) {
        for (let col = 0; col < colLen; col++) {
            if (row === 0 && col === 0) continue;
            
            if (obstacleGrid[row][col] === 0) {
                dp[row][col] = (dp[row - 1]?.[col] || 0) + (dp[row][col - 1] || 0);
            }
        }
    }
    return dp[rowLen - 1][colLen - 1];
};
```

# Complexity
**Time:** O(m * n)**Space:** O(m * n)
