# Minimum Cost Path with Edge Reversals
[3650. Minimum Cost Path with Edge Reversals](https://leetcode.com/problems/minimum-cost-path-with-edge-reversals/)

# Key insights

- **Reversing an incoming edge is just a reverse edge with 2x cost** — for each edge `u → v` with cost `w`, add both `(u→v, w)` and `(v→u, 2w)` to the graph upfront
- This transforms the problem into a standard **Dijkstra's shortest path** from node 0 to node n-1
- Early exit: return immediately when node `n-1` is dequeued (guaranteed shortest)
- Skip stale entries: if `curr.dist > dist[curr.node]`, a shorter path was already found

# Code
```javascript
var minCost = function (n, edges) {
    const graph = Array.from({ length: n }, () => []);
    for (const [u, v, w] of edges) {
        graph[u].push([v, w]);
        graph[v].push([u, 2 * w]);
    }

    const dist = Array(n).fill(Infinity);
    dist[0] = 0;
    const pq = new PriorityQueue((a, b) => a.dist - b.dist);
    pq.enqueue({ dist: 0, node: 0 });

    while (!pq.isEmpty()) {
        const curr = pq.dequeue();

        if (curr.node === n - 1) {
            return curr.dist;
        }

        if (curr.dist > dist[curr.node]) continue;

        for (const [next, weight] of graph[curr.node]) {
            if (curr.dist + weight < dist[next]) {
                dist[next] = curr.dist + weight;
                pq.enqueue({ dist: dist[next], node: next });
            }
        }
    }

    return -1;
};
```

# Complexity

- **Time**: O((n + m) log m) — Dijkstra with a min-heap over m edges (doubled to 2m with reverse edges)
- **Space**: O(n + m) — adjacency list and distance array
